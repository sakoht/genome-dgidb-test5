package Genome::ProcessingProfile::Test;

use strict;
use warnings;

use base 'Genome::Utility::TestBase';

use Carp 'confess';
use Data::Dumper 'Dumper';
use Genome;
use Test::More;

#< Processing Profile and Commands for Testing >#
class Genome::ProcessingProfile::Tester {
    is => 'Genome::ProcessingProfile::Staged',
    has_param => [
    # Attrs
    sequencing_platform => { 
        is => 'Text',
        doc => 'The sequencing_platform of this profile',
    },
    dna_source => {
        is => 'Text',
        doc => 'The dna source of this profile',
    },
    ],
    has => [
    # Methods
    prepare_objects => {
        calculate => q| return 1; |,
        is_constant => 1,
    },
    prepare_job_classes => {
        calculate => q| return (qw/ Genome::ProcessingProfile::Tester::Prepare /); |,
        is_constant => 1,
    },
    assemble_objects => {
        calculate => q| return 1; |,
        is_constant => 1,
    },
    ],
};
sub Genome::ProcessingProfile::Tester::stages {
     return (qw/ prepare assemble /);
}
sub Genome::ProcessingProfile::Tester::assemble_job_classes {
     return (qw/ 
         Genome::ProcessingProfile::Tester::PreAssemble 
         Genome::ProcessingProfile::Tester::Assemble 
         Genome::ProcessingProfile::Tester::PostAssemble 
         /);
}

# Prepare
class Genome::ProcessingProfile::Tester::Prepare {
    is => 'Genome::Model::Event',
};

# Assemble
class Genome::ProcessingProfile::Tester::PreAssemble {
    is => 'Genome::Model::Event',
};
class Genome::ProcessingProfile::Tester::Assemble {
    is => 'Genome::Model::Event',
};
class Genome::ProcessingProfile::Tester::PostAssemble {
    is => 'Genome::Model::Event',
};
#<>#
sub test_class {
    return 'Genome::ProcessingProfile';
}

sub params_for_test_class {
    my %params = Genome::ProcessingProfile::Test->valid_params_for_type_name('tester');
    delete $params{class};
    return %params;
}

sub required_params_for_class {
    return (qw/ name /);
}

sub invalid_params_for_test_class {
    return (
        type_name => 'not tester',
    );
}

sub test_startup : Test(startup => 2) {
    my $self = shift;

    $ENV{UR_DBI_NO_COMMIT} = 1;
    ok($ENV{UR_DBI_NO_COMMIT}, 'No commit') or die;
    $ENV{UR_USE_DUMMY_AUTOGENERATED_IDS} = 1;
    ok($ENV{UR_USE_DUMMY_AUTOGENERATED_IDS}, 'Dummy ids') or die;

    return;
}
    
sub test01_creates : Tests(4) {
    my $self = shift;

    my %params = $self->params_for_test_class;
    my $name = delete $params{name};

    # CREATE W/ DNA SOURCE UNDEF AND SEQ_PLAT IS THE SAME
    my $dna_source = delete $params{dna_source};
    my $pp_w_undef_dna_source = $self->test_class->create(
        name => 'Dna Source is undef', 
        %params,
    );
    ok(
        $pp_w_undef_dna_source,
        'Create w/ dna_source undef',
    );
    #$pp_w_undef_dna_source->delete;
    $params{dna_source} = $dna_source;

    # DUPLICATES
    # name
    ok(
        !$self->test_class->create(
            name => $name, 
            %params
        ),
        'Create failed - duplicate named pp not allowed'
    );
    # params - diff name
    ok(
        !$self->test_class->create(
            name => 'Diff Name',
            %params
        ),
        'Create failed - duplicate param pp not allowed',
    );
    
    my $type_name = delete $params{type_name};

    # TYPE NAME UNRESOLVABLE
    delete $params{type_name};
    eval { # this should die
        $self->test_class->create(
            name => 'Diff Name',
            %params,
        );
    };
    ok($@, 'Create failed - can\'t resolve type_name');

    return 1;
}

sub test02_resolvers : Tests(3) {
    my $self = shift;

    is(
        Genome::ProcessingProfile::Tester->_resolve_type_name_for_class,
        'tester',
        '_resolve_type_for_subclass_name Genome::ProcessingProfile::Tester => tester',
    );
    is(
        Genome::ProcessingProfile->_resolve_type_name_for_class,
        undef, 
        '_resolve_type_for_subclass_name Genome::ProcessingProfile => undef ',
    );
    is(
        Genome::ProcessingProfile->_resolve_subclass_name_for_type_name('tester'),
        'Genome::ProcessingProfile::Tester',
        '_resolve_subclass_name_for_type_name tester => Genome::ProcessingProfile::Tester'
    );

    return 1;
}

sub test03_methods : Tests(4) {
    my $self = shift;

    my $pp = $self->{_object};
    is($pp->type_name, 'tester', 'Checking type_name (tester)');
    is_deeply([ $pp->params_for_class ], [qw/ sequencing_platform dna_source /], 'params_for_class');
    is($pp->sequencing_platform, 'solexa', 'sequencing_platform (solexa)');
    is($pp->dna_source, 'genomic', 'dna_source (genomic)');

    return 1;
}

#< MOCK ># 
sub create_mock_processing_profile {
    my ($self, $type_name) = @_; # seq plat for ref align

    # Create
    my %params = $self->valid_params_for_type_name($type_name);
    unless ( %params ) {
        confess "No params for type name ($type_name).";
    }
    my %create_params = map { $_ => delete $params{$_} } (qw/ class name type_name /);
    my $pp = $self->create_mock_object(%create_params)
        or confess "Can't create mock processing profile for '$type_name'";
    
    # Methods 
    $self->mock_methods(
        $pp,
        (qw/
            params_for_class
            stages objects_for_stage classes_for_stage
            delete
            /),
    );

    # PP Params
    for my $param ( $pp->params_for_class ) {
        $self->mock_accessors($pp, $param);
        $pp->$param( delete $params{$param} );
    }

    # Stages
    for my $stage ( $pp->stages ) {
        $self->mock_methods(
            $pp,
            $stage.'_objects', $stage.'_job_classes',
        );
    }

    #< Specific Mocking >#
    my $additional_methods_method = '_add_mock_methods_to_'.join(
        '_', split(/\s/, $pp->type_name)
    );
    if ( $self->can($additional_methods_method) ) {
        $self->$additional_methods_method($pp)
            or confess "Can't add additional methods for $type_name";
    }

    return $pp;
}

#< Valid Params >#
my %TYPE_NAME_PARAMS = (
    tester => {
        class => 'Genome::ProcessingProfile::Tester',
        type_name => 'tester',
        name => 'Tester for Testing',
        sequencing_platform => 'solexa',
        dna_source => 'genomic',
    }, 
    'amplicon assembly' => {
        class => 'Genome::ProcessingProfile::AmpliconAssembly',
        type_name => 'amplicon assembly',
        name => '16S Test 27F to 1492R (907R)',
        assembler => 'phredphrap',
        assembly_size => 1465,
        primer_amp_forward => '18SEUKF:ACCTGGTTGATCCTGCCAG',
        primer_amp_reverse => '18SEUKR:TGATCCTTCYGCAGGTTCAC',
        primer_seq_forward => '502F:GGAGGGCAAGTCTGGT',
        primer_seq_reverse => '1174R:CCCGTGTTGAGTCAAA',
        purpose => 'composition',
        region_of_interest => '16S',
        sequencing_center => 'gsc',
        sequencing_platform => 'sanger',
    }, 
    'reference alignment solexa' => {
        class => 'Genome::ProcessingProfile::ReferenceAlignment::Solexa',
        type_name => 'reference alignment',
        name => 'Ref Align Solexa Test',
        sequencing_platform => 'solexa',
        dna_type => 'genomic dna',
        genotyper_name => undef,
        genotyper_params => undef,
        indel_finder_name => undef,
        indel_finder_params => undef,
        multi_read_fragment_strategy => undef,
        read_aligner_name => undef,
        read_aligner_version => undef,
        read_aligner_params => undef,
        read_calibrator_name => undef,
        read_calibrator_params => undef,
        prior_ref_seq => undef,
        reference_sequence_name => undef,
        align_dist_threshold => undef,
    },
    'reference alignment 454' => {
        class => 'Genome::ProcessingProfile::ReferenceAlignment::454',
        type_name => 'reference alignment',
        name => 'Ref Align 454 Test',
        sequencing_platform => '454',
        dna_type => 'genomic dna',
        genotyper_name => undef,
        genotyper_params => undef,
        indel_finder_name => undef,
        indel_finder_params => undef,
        multi_read_fragment_strategy => undef,
        read_aligner_name => undef,
        read_aligner_version => undef,
        read_aligner_params => undef,
        read_calibrator_name => undef,
        read_calibrator_params => undef,
        prior_ref_seq => undef,
        reference_sequence_name => undef,
        align_dist_threshold => undef,
    },
    'de novo assembly' => {
        class => 'Genome::ProcessingProfile::DeNovoAssembly',
        name => 'Duh Novo Test',
        type_name => 'de novo assembly',
        sequencing_platform => 'solexa',
        assembler_name => 'velvet',
        assembler_version => '0.7.30',
        assembler_params => '-hash_length 27 ',
        prepare_instrument_data_params => '-reads_cutoff 10000',
    },
    'virome screen' => {
	class => 'Genome::ProcessingProfile::ViromeScreen',
	name => 'Virome Screen Test',
	type_name => 'virome screen',
	sequencing_platform => '454',
    },
);
sub valid_params_for_type_name {
    my ($self, $type_name) = @_;

    confess "No type name given" unless $type_name;

    return unless exists $TYPE_NAME_PARAMS{$type_name};

    return %{$TYPE_NAME_PARAMS{$type_name}};
}

#< Additional Methods for Mock PP Type Names >#
# TODO
#sub _add_mock_methods_to_amplicon_assembly { }

sub _add_mock_methods_to_de_novo_assembly { 
    my ($self, $pp) = @_;

    $self->mock_methods(
        $pp, 
        (qw/ 
            get_param_string_as_hash _validate_params_for_step 
            get_prepare_instrument_data_params get_assemble_params get_preprocess_params 
            /),
    );

    return 1;
}

#sub _add_mock_methods_to_tester { }
#sub _add_mock_methods_to_reference_alignement { }

# NO ADDITIONAL METHODS TO MOCK FOR VIROME SCREEN
#sub _add_mock_methods_to_virome_screen { }

#######################
# Type Name Test Base #
#######################

package Genome::ProcessingProfile::TestBase;

use strict;
use warnings;

use base 'Genome::Utility::TestBase';

use Data::Dumper 'Dumper';
require Scalar::Util;
use Test::More;

sub pp { # the valid processing profile
    return $_[0]->{_object};
}

sub class_name {
    return ( Scalar::Util::blessed($_[0]) || $_[0] );
}

sub test_class {
    my $class = $_[0]->class_name;
    $class =~ s#::Test$##;
    return $class
}

sub type_name {
    my ($subclass) = $_[0]->test_class =~ m#Genome::ProcessingProfile::(\w+)#;
    return Genome::Utility::Text::camel_case_to_string($subclass);
}

sub full_type_name {
    my ($subclass) = $_[0]->test_class =~ m#Genome::ProcessingProfile::(.+)#;
    return join(
        ' ',
        map { Genome::Utility::Text::camel_case_to_string($_) }
        split('::', $subclass)
    );
}

sub params_for_test_class {
    my $self = shift;

    unless ( $self->{_params_for_class} ){
        my %params = Genome::ProcessingProfile::Test->valid_params_for_type_name( $self->full_type_name );
        delete $params{class};
        for my $key ( keys %params ) {
            delete $params{$key} unless defined $params{$key};
        }
        $self->{_params_for_class} = \%params;
    }

    return %{$self->{_params_for_class}};
}

# TODO test params?

#####################
# Amplicon Assembly #
#####################

package Genome::ProcessingProfile::AmpliconAssembly::Test;

use strict;
use warnings;

use base 'Genome::ProcessingProfile::TestBase';

sub invalid_params_for_test_class {
    return (
        primer_amp_forward => 'AAGGTGAGCCCGCGATGCGAGCTTAT',
        primer_amp_reverse => '55:55',
        sequencing_platform => 'super-seq',
        sequencing_center => 'monsanto',
        purpose => 'because',
    );
}

#######################
# Reference Alignment #
#######################

package Genome::ProcessingProfile::ReferenceAlignment::454::Test;

use strict;
use warnings;

use base 'Genome::ProcessingProfile::TestBase';

# TODO 
# sub invalid_params_for_test_class { }

package Genome::ProcessingProfile::ReferenceAlignment::Solexa::Test;

use strict;
use warnings;

use base 'Genome::ProcessingProfile::TestBase';

# TODO 
# sub invalid_params_for_test_class { }

############
# Commands #
############

package Genome::ProcessingProfile::Command::TestBase;

use strict;
use warnings;

use base 'Genome::Utility::TestBase';

sub test_class {
    return 'Genome::ProcessingProfile::Command::'.$$_[0]->subclass;
}

sub command_name {
    return Genome::Utility::Text::camel_case_to_string($_[0]->subclass);
}

sub params_for_test_class {
    return (
        $_[0]->_params_for_test_class,
    );
}

sub _params_for_test_class { 
    return;
}

sub test01_execute : Tests() {
    my $self = shift;

    ok($self->{_object}->execute, 'Executed '.$self->command_name);

    return 1;
}

sub test01_invalid : Tests() {
    my $self = shift;

    #ok($self->{_object}->execute, 'Executed '.$self->command_name);

    return 1;
}

# List - this class only runs the UR::Object::Command::List
package Genome::ProcessingProfile::Command::List::Test;

use strict;
use warnings;

use base 'Test::Class';

use Test::More;

sub test01 : Tests(2) {
    my $self = shift;

    my $test_class = 'Genome::ProcessingProfile::Command::List';
    use_ok($test_class);
    is(
        $test_class->__meta__->property_meta_for_name('subject_class_name')->default_value,
        'Genome::ProcessingProfile',
        'Subject class name',
    );
    
    return 1;
}

###################################################
###################################################

1;

#$HeadURL$
#$Id$
