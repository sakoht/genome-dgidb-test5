package Genome::Disk::Allocation;

# Adaptor for GSC::DiskAllocation

# Do NOT use this module from anything in the GSC schema,
# though the converse will work just fine.

# This module will handle all PSE calls based on modifications

use strict;
use warnings;

use Genome;

class Genome::Disk::Allocation {
    table_name => "(select * from disk_allocation\@dw) disk_allocation",
    id_by => [
              allocator_id => {
                               is => 'Number',
                               doc => 'The id for the allocator event',
                           },
          ],
    has => [
            disk_group_name => {
                                  is => 'Text',
                                  doc => 'The name of the disk group',
                              },
            mount_path => {
                           is => 'Text',
                           doc => 'The mount path of the disk volume',
                       },
            allocation_path => {
                                is => 'Text',
                                doc => 'The sub-dir of the disk volume for which space is allocated',
                            },
            kilobytes_requested => {
                                    is => 'Number',
                                    doc => 'The disk space allocated in kilobytes',
                                },
            kilobytes_used => {
                               is => 'Number',
                               doc => 'The actual disk space used by owner',
                           },
            owner_class_name => {
                                 is => 'Text',
                                 doc => 'The class name for the owner of this allocation',
                             },
            owner_id => {
                         is => 'Number',
                         doc => 'The id for the owner of this allocation',
                         },
            group_subdirectory => {
                                   is => 'Text',
                                   doc => 'The group specific subdirectory where space is allocated',
            },
            absolute_path => {
                              calculate_from => ['mount_path','group_subdirectory','allocation_path'],
                              calculate => q|
                                  return $mount_path .'/'. $group_subdirectory .'/'. $allocation_path;
                              |,
                          },
        ],
        has_optional => [
                         allocator => {
                                       calculate_from => 'allocator_id',
                                       calculate => q|
                                                     return GSC::PSE::AllocateDiskSpace->get($allocator_id);
                                       |,
                                       doc => 'The allocate disk space PSE',
                                   },
                     ],
        data_source => 'Genome::DataSource::GMSchema',
};

sub create {
    my $class = shift;
    my $self = $class->SUPER::create(@_);

    my @required_params = qw (allocation_path disk_group_name kilobytes_requested owner_class_name owner_id);
    for (@required_params) {
        unless (defined($self->$_)) {
            $self->error_message($_ .' param is required!');
            $self->delete;
            return;
        }
    }
    if ($ENV{UR_DBI_NO_COMMIT} || $ENV{UR_USE_DUMMY_AUTOGENERATED_IDS}) {
        die('There is no real good way to test disk allocation right now');
    }
    my $allocate_cmd = sprintf('genome disk allocation allocate --allocation-path=%s --disk-group-name=%s --kilobytes-requested=%s --owner-class-name=%s --owner-id=%s',
                               $self->allocation_path,
                               $self->disk_group_name,
                               $self->kilobytes_requested,
                               $self->owner_class_name,
                               $self->owner_id,
                           );

    my $rv = system($allocate_cmd);
    unless ($rv == 0) {
        $self->error_message('Failed to allocate disk space with command '. $allocate_cmd);
        $self->delete;
        return;
    }
    my $allocation = Genome::Disk::Allocation->get(
                                                   allocation_path => $self->allocation_path,
                                                   disk_group_name => $self->disk_group_name,
                                                   owner_class_name => $self->owner_class_name,
                                                   owner_id => $self->owner_id,
                                               );
    unless ($allocation) {
        $self->error_message('Failed to get '. $self->disk_group_name .' disk allocation for '. $self->owner_class_name .'('. $self->owner_id
                             .') with allocation path '. $self->allocation_path);
        $self->delete;
        return;
    }
    $self->delete;
    return $allocation;
}

sub reallocate {
    my $self = shift;
    if ($ENV{UR_DBI_NO_COMMIT} || $ENV{UR_USE_DUMMY_AUTOGENERATED_IDS}) {
        die('There is no real good way to test disk allocation right now');
    }
    my $reallocate_cmd = sprintf('genome disk allocation reallocate --wait-for-pse --allocator-id=%s',$self->allocator_id);
    my $rv = system($reallocate_cmd);
    unless ($rv == 0) {
        $self->error_message('Failed to reallocate disk space with command '. $reallocate_cmd);
        return;
    }
    return 1;
}

sub deallocate {
    my $self = shift;
    if ($ENV{UR_DBI_NO_COMMIT} || $ENV{UR_USE_DUMMY_AUTOGENERATED_IDS}) {
        die('There is no real good way to test disk allocation right now');
    }
    my $deallocate_cmd = sprintf('genome disk allocation deallocate --wait-for-pse --allocator-id=%s',$self->allocator_id);
    my $rv = system($deallocate_cmd);
    unless ($rv == 0) {
        $self->error_message('Failed to deallocate disk space with command '. $deallocate_cmd);
        return;
    }
    return 1;
}

1;




