package Genome::Model::Command::Status::GoldSnpMetrics;

use strict;
use warnings;
use Genome;
use Data::Dumper;
use XML::LibXML;

class Genome::Model::Command::Status::GoldSnpMetrics {
    is => ['Command'],
    has_optional => [
        genome_model_id => { 
            is => 'String', 
            doc => 'Required genome model id upon which the report is run.',
        },
        genome_model_ids=> { 
            is => 'String', 
            doc => 'Required genome model id upon which the report is run.',
        },
        display_output => {
            is => 'Integer',
            default_value => 1,
            doc => "A flag which lets the user supress the display of XML output to the screen.", 
        }, 
        _models => {
            is => 'List',
            doc => 'Models incorporated into the report',
        },
        _doc => {
            is => 'XML::LibXML::Document',
            doc => "The XML tool used to create all nodes of the output XML tree.",
        },
        _xml => {
            is => 'Text',
            doc => "The XML generated by the status call.",
        },
    ],
};


sub execute {
    my $self = shift;

    if (!$self->genome_model_id && !$self->genome_model_ids) {
        die "You must provide at least a --genome-model-id or --genome-model-ids.  If passing genome model ids, use a space separated list wrapped with quotes";
    }

    my @models;
    if ($self->genome_model_id) {
        @models = (Genome::Model->get($self->genome_model_id));
    } else {
        my @ids = split /\s+/,$self->genome_model_ids;
        @models = map {Genome::Model->get($_)} @ids;
    }

    $self->_models(\@models);

    my $doc = XML::LibXML->createDocument();
    $self->_doc($doc);
    my $report_node = $doc->createElement("report");
    $doc->setDocumentElement($report_node);
    $report_node->addChild($self->_get_meta_node());

    my $dataset_node = $doc->createElement("dataset");

    for my $model (@models) {
        $dataset_node->addChild($self->_get_model_node($model));
    }
    $report_node->addChild($dataset_node);
    
    $self->_xml($doc->toString(1));

    if ($self->display_output) {
        print $self->_xml;
    }

    return 1;
}

sub _get_model_node {
    my $self = shift;
    my $model = shift;

    my $model_node = $self->anode("model","id",$model->id,"name",$model->name,"processing-profile",$model->processing_profile_name,"username",$model->user_name,"type", $model->class);

    my @builds = $model->builds;
    for (@builds) {
        my $metrics = $self->_metrics_for_build($_);
        next if ($metrics->{gigabases} == 0);

        my $build_node = $self->anode("build","id",$_->id);
        $build_node->addChild($self->tnode('lanes',$metrics->{lanes}));
        $build_node->addChild($self->tnode('gigabases',$metrics->{gigabases}));
        $build_node->addChild($self->tnode('goldsnp-concordance-filtered',$metrics->{goldsnp_concordance_filtered}));

        $model_node->addChild($build_node);
    }
   
    return $model_node; 
}

sub _get_meta_node {
    my $self =  shift;

    my @models = @{$self->_models};

    my $meta_node = $self->_doc->createElement("report-meta");

    $meta_node->addChild($self->tnode('name','Model Builds Report'));
    $meta_node->addChild($self->tnode('description','Shows the gigabases, filtered gold SNP concordance, and flow cells for all the builds in a model'));
    $meta_node->addChild($self->tnode('date',UR::Time->now()));
    $meta_node->addChild($self->tnode('generator',ref($self)));
    
    my $params_node = $self->_doc->createElement("generator-params");
    for my $model_node (map {$self->tnode('model-id', $_->id)} @models) {
        $params_node->addChild($model_node);
    }
    $meta_node->addChild($params_node);

    return $meta_node;

}

sub _metrics_for_build {
    my $self = shift;
    my $build = shift;
    
    my $het_metric_name='gold-heterozygous-snp match heterozygous-1-allele-variant filtered';
    my $kb_metric_name='instrument data total kb';

    my $het_value = ($build->get_metric($het_metric_name) || 0);
    my $kb_value = ($build->get_metric($kb_metric_name) || 0);
    
    my $gb_value = $kb_value/1000000;

    my @idas = $build->instrument_data_assignments;

    return {"lanes"=>scalar @idas, "goldsnp_concordance_filtered" => $het_value, "gigabases" => $gb_value};
}

sub create_node_with_attribute {
    
    my $self = shift;
    my $node_name = shift;

    my $doc = $self->_doc;
    
    my $node = $doc->createElement($node_name);
    while (my $attr_name = shift ) {
        my $attr_value = shift;
        $node->addChild($doc->createAttribute($attr_name,$attr_value));
    }
    return $node;
} 

#helper methods.  just pass through to the more descriptive names 
#anode = attribute node
sub anode {
    my $self = shift;
    return $self->create_node_with_attribute(@_);
}
 
#tnode = text node
sub tnode {
    my $self = shift; 
    return $self->create_node_with_text(@_);
}
 
sub create_node_with_text {
    my $self = shift;
    my $node_name = shift;
    my $node_value = shift;

    my $doc = $self->_doc;
    
    my $node = $doc->createElement($node_name);
    if ( defined($node_value) ) {
        $node->addChild($doc->createTextNode($node_value));
    } 
    return $node;

} 

