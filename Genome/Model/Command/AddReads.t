#!/gsc/bin/perl

##########################
####TODO: limit_regions is not being set on UR::Context->_sync_databases



############################
# New Add Reads test suite
############################


use strict;
use warnings;

use Data::Dumper;
use File::Temp;
use File::Path;
use above "Genome";
use Command;
use Genome::Model::Tools::Maq::CLinkage0_6_5;
use Genome::RunChunk;
App::DB->db_access_level('rw');
App::DB::TableRow->use_dummy_autogenerated_ids(1);
App::DBI->no_commit(1);
App->init;

#####DEFINE TEST NUMBER HERE####
use Test::More;
use Test::Differences;
###############################

my %directories_to_remove;

$ENV{UR_DBI_NO_COMMIT} = 1;
$ENV{UR_USE_DUMMY_AUTOGENERATED_IDS} = 1;

#$ENV{UR_DBI_MONITOR_DML} = 1;
#$ENV{UR_DBI_MONITOR_SQL} = 1;

my $archos = `uname -a`;
if ($archos !~ /64/) {
    plan skip_all => "Must run from 64-bit machine";
}

my $platform  = 'solexa';
#my $platform = '454';
my $model_name = 'test_'. $platform ."_$ENV{USER}";
my $pp_name = 'test_'. $platform ."_pp_$ENV{USER}";
my $dna_type = 'genomic dna';
my $align_dist_threshold = '0';
my $reference_sequence = 'refseq-for-test';
my $multi_read_fragment_strategy = 'EliminateAllDuplicates';

my ($sample,$indel_finder,$genotyper,$read_aligner,$read_aligner_params);
if ($platform eq '454') {
    plan qw(no_plan);

    # Seems to be a small data set
    #$sample = 'H_FY-454_080213_TSP_SetN4';
    #$sample = 'H_IL-TSP_tn_pool_flx_tube1-051508a';
    $sample = 'H_FY-454_96normal_tspset1_9amps';
    $indel_finder = 'breakPointRead454';
    $genotyper = 'gsMapper';
    $read_aligner = 'blatPlusCrossmatch';
    $read_aligner_params = 'v32x1 -mask=lower -out=pslx;v1.080426';
} elsif ($platform eq 'solexa') {
    plan tests => 460;

    $sample = 'H_GV-933124G-skin1-9017g';
    $indel_finder = 'maq0_6_3';
    $genotyper = 'maq0_6_3';
    $read_aligner = 'maq0_6_3';
}

######## test command processing profile short reads create. ########
my $create_pp_command= Genome::Model::Command::Create::ProcessingProfile::ShortRead->create(
     indel_finder          => $indel_finder,
     dna_type              => $dna_type,
     align_dist_threshold  => $align_dist_threshold,
     reference_sequence    => $reference_sequence,
     genotyper             => $genotyper ,
     read_aligner          => $read_aligner,
     read_aligner_params   => $read_aligner_params,
     profile_name	   => $pp_name,
     sequencing_platform   => $platform,
     multi_read_fragment_strategy => $multi_read_fragment_strategy,
     bare_args => [],
 );


# check and create the processing profile
isa_ok($create_pp_command,'Genome::Model::Command::Create::ProcessingProfile::ShortRead');
ok($create_pp_command->execute(), 'execute processing profile create');     

# Get it and make sure there is one
my @processing_profiles = Genome::ProcessingProfile::ShortRead->get(name => $pp_name);
is(scalar(@processing_profiles),1,'expected one processing profile');

# check the type
my $pp = $processing_profiles[0];
isa_ok($pp ,'Genome::ProcessingProfile::ShortRead');

# Test the properties were set and the accessors functionality
is($pp->indel_finder_name,$indel_finder,'processing profile indel_finder accessor');
is($pp->dna_type,$dna_type,'processing profile dna_type accessor');
is($pp->align_dist_threshold,$align_dist_threshold,'processing profile align_dist_threshold accessor');
is($pp->reference_sequence_name,$reference_sequence,'processing profile reference_sequence accessor');
is($pp->genotyper_name,$genotyper,'processing profile genotyper accessor');
is($pp->read_aligner_name,$read_aligner,'processing profile read_aligner accessor');
is($pp->name,$pp_name,'processing profile name accessor');
is($pp->multi_read_fragment_strategy ,$multi_read_fragment_strategy ,'processing profile multi_read_fragment_strategy accessor');
is($pp->sequencing_platform ,$platform ,'processing profile sequencing_platform accessor');

####### test command create.

######## test command create for a genome model ########
my $create_command= Genome::Model::Command::Create::Model->create(
  	model_name            	=> $model_name,
        sample                  => $sample,
	processing_profile_name => $pp_name,
	bare_args 				=> [],
);

isa_ok($create_command,'Genome::Model::Command::Create::Model');

my $result = $create_command->execute();
ok($result, 'execute genome-model create');

my $genome_model_id = $result->id;

UR::Context->_sync_databases();

my @models = Genome::Model->get($genome_model_id);
is(scalar(@models),1,'expected one model');

my $model = $models[0];
$model->test(1);

isa_ok($model,'Genome::Model');

is($model->genome_model_id,$genome_model_id,'genome_model_id accessor');
is($model->indel_finder_name,$indel_finder,'indel_finder accessor');
is($model->name,$model_name,'model_name accessor');
is($model->sample_name,$sample,'sample accessor');
is($model->dna_type,$dna_type,'dna_type accessor');
is($model->align_dist_threshold,$align_dist_threshold,'align_dist_threshold accessor');
is($model->reference_sequence_name,$reference_sequence,'reference_sequence accessor');
is($model->genotyper_name,$genotyper,'genotyper accessor');
is($model->read_aligner_name,$read_aligner,'read_aligner accessor');

###genome model add-reads section

my @read_sets = &setup_test_data;

###RUN ADD-READS. This should make scheduled
for my $read_set (@read_sets) {
    my $add_reads_command = Genome::Model::Command::AddReads->create(
                                                                     model_id => $genome_model_id,
                                                                     read_set_id => $read_set->seq_id,
                                                                 );
    isa_ok($add_reads_command,'Genome::Model::Command::AddReads');
    ok($add_reads_command->execute(),'execute genome-model add-reads');
    UR::Context->_sync_databases();

    my @add_reads_events = Genome::Model::Event->get(
                                                     model_id => $model->id,
                                                     parent_event_id => $add_reads_command->id,
                                                 );
    is(scalar(@add_reads_events),4,'get scheduled genome_model_events');
    # sort by event id to ensure order of events matches pipeline order
    @add_reads_events = sort {$b->genome_model_event_id <=> $a->genome_model_event_id} @add_reads_events;

    my $assign_run_command = $add_reads_events[0];
    isa_ok($assign_run_command,'Genome::Model::Command::AddReads::AssignRun');

    my $data_directory = $assign_run_command->model->data_directory;
    ok(-d $data_directory, "data directory '$data_directory' exists");
    $directories_to_remove{$data_directory} = 1;

    my $run_directory = $assign_run_command->resolve_run_directory;
    #this happens on a different granularity--- one per 8 lanes/flowcell for solexa. figure out this later
    #ok(!-e $run_directory, "run directory '$run_directory' not created yet");

    #my $adaptor_file = $assign_run_command->adaptor_file_for_run;
    #ok(!-e $adaptor_file, "adaptor_file '$adaptor_file' not created yet");

    #my $orig_unique_file = $assign_run_command->original_sorted_unique_fastq_file_for_lane;
    #ok(-s $orig_unique_file, "orig_unique_file '$orig_unique_file' exists from CQADR with non-zero size");

    #my $our_unique_file = $assign_run_command->sorted_unique_fastq_file_for_lane;
    #ok(!-e $our_unique_file, "our_unique_file '$our_unique_file' not created yet");

    #this test will only test uniques for now.
    #my $orig_duplicate_file = $assign_run_command->original_sorted_duplicate_fastq_file_for_lane;
    #ok(-s $orig_duplicate_file, "orig_duplicate_file '$orig_duplicate_file' exists from CQADR with non-zero size");

    #my $our_duplicate_file = $assign_run_command->sorted_duplicate_fastq_file_for_lane;
    #ok(!-e $our_duplicate_file, "our_duplicate_file '$our_duplicate_file' not created yet");

    &execute_test($assign_run_command,$read_set);

    ok(-d $run_directory, 'run_directory created');

    #ok(-f $adaptor_file, 'adaptor_file created');
    #ok(-l $our_unique_file, 'our_unique_file symlink created');

    #This test will only test uniques for now.
    #ok(-l $our_duplicate_file, 'our_duplicate_file symlink created');

    ###RUN ALIGN-READS VIA BSUBHELPER(?). 
    my $align_reads_command = $add_reads_events[1];
    isa_ok($align_reads_command,'Genome::Model::Command::AddReads::AlignReads');

    my $align_reads_ref_seq_file =  $align_reads_command->model->reference_sequence_path . "/all_sequences.bfa";
    #If the files are binary then the size of an empty file is greater than zero(20?)
    ok(-s $align_reads_ref_seq_file, 'align-reads reference sequence file exists with non-zero size');

    &execute_test($align_reads_command,$read_set);

    #TODO: TEST THE RESULT OF ALIGN READS
    #Compare the map file to the test data

    my $proc_low_qual_command = $add_reads_events[2];
    isa_ok($proc_low_qual_command,'Genome::Model::Command::AddReads::ProcessLowQualityAlignments');
    &execute_test($proc_low_qual_command,$read_set);

    my $accept_reads_command = $add_reads_events[3];
    isa_ok($accept_reads_command,'Genome::Model::Command::AddReads::AcceptReads');
    &execute_test($accept_reads_command,$read_set);
}

my $pp_alignments = Genome::Model::Command::AddReads::PostprocessAlignments->create(
                                                                                    model_id => $model->id,
                                                                                );
isa_ok($pp_alignments,'Genome::Model::Command::AddReads::PostprocessAlignments');
ok($pp_alignments->execute(), 'execute genome-model add-reads postprocess-alignments');
UR::Context->_sync_databases();

my @pp_events = Genome::Model::Event->get(
                                          model_id => $model->id,
                                          parent_event_id => $pp_alignments->id,
                                      );
is(scalar(@pp_events),15,'get scheduled genome_model add-reads postprocess-alignments');
# sort by event id to ensure order of events matches pipeline order
@pp_events = sort {$b->genome_model_event_id <=> $a->genome_model_event_id} @pp_events;

my $merge_alignments_command = $pp_events[0];
isa_ok($merge_alignments_command,'Genome::Model::Command::AddReads::MergeAlignments');
&execute_test($merge_alignments_command);

$DB::single=1;
my $update_genotype_command = $pp_events[1];
isa_ok($update_genotype_command,'Genome::Model::Command::AddReads::UpdateGenotype');
&execute_test($update_genotype_command);

my $find_variations_command = $pp_events[2];
isa_ok($find_variations_command,'Genome::Model::Command::AddReads::FindVariations');
&execute_test($find_variations_command);

###HERES THE UNLOCK MAGIC...ARE YOU READY?
rmtree $model->lock_directory;


my $pp_variations_command = $pp_events[3];
isa_ok($pp_variations_command,'Genome::Model::Command::AddReads::PostprocessVariations');
&execute_test($pp_variations_command);


my $annotate_variations_command = $pp_events[4];
isa_ok($annotate_variations_command,'Genome::Model::Command::AddReads::AnnotateVariations');
&execute_test($annotate_variations_command);

#my $filter_variations_command = $pp_events[5];

#my $upload_database_command = $pp_events[6];



##NOTES-------------
## I desire cookies...please bring cookies now.
exit;

END {
    for my $directory_to_remove (keys %directories_to_remove) {
        print $directory_to_remove . "\n";
        unless (defined($platform) && $platform eq '454') {
            rmtree $directory_to_remove;
        }
    }
}

sub execute_test  {
    my ($event,$read_set) = @_;

    my $event_model = $event->model;
    $event_model->test(1);
    eq_or_diff($model,$event_model,'genome-model comparison');

    # Not working for EventWithReadSet
    if (defined $event->run_id) {
        my $read_set = $event->read_set;
        isa_ok($read_set,'Genome::RunChunk');
        is($read_set->seq_id,$read_set->seq_id,'genome-model read_set_id => sls seq_id ');
    }

    ok($event->execute(),'Execute: '. $event->command_name)
        ? &set_status($event,'Succeeded')
            : &set_status($event,'Failed');

    #TODO: Write a verify_successful_completion method in all events
    #ok($event->verify_successful_completion,'Verify: '. $event->command_name)

    UR::Context->_sync_databases();
}

sub set_status {
    my ($event,$status) = @_;
    my $now = UR::Time->now;
    $event->event_status($status);
    $event->date_completed($now);
}


sub setup_test_data {
    my @read_sets;
    if ($platform eq '454') {
        my $data_dir = $model->data_directory;
        # A small data set to test with(origin unknown)
        @read_sets = GSC::RunRegion454->get(
                                            incoming_dna_name => $sample,
                                        );
    } elsif ($platform eq 'solexa') {

        ####If we have a test gzip of files, we need to unzip it here

        ####Maybe create Genome::RunChunk(s)?
        ###teh gzips are teh key here.... DR. SCHUSTE has provided us with some suitably tiny fastqs in gzip form.

        use FindBin qw($Bin);

        my $tmp_dir = File::Temp::tempdir();
        $directories_to_remove{$tmp_dir} = 1;
        chdir $tmp_dir;

        my $zip_file = '/gsc/var/cache/testsuite/data/Genome-Model-Command-AddReads/addreads.tgz';
        `tar -xzf $zip_file`;

        my @run_dirs = grep { -d $_ } glob("$tmp_dir/*_*_*_*");
        for my $run_dir (@run_dirs) {
            my $run_dir_params = GSC::PSE::SolexaSequencing::SolexaRunDirectory->parse_regular_run_directory($run_dir);
            #print Dumper $run_dir_params;
            for my $lane (1 .. 8) {
                my $sls = GSC::RunLaneSolexa->create(
                                                     run_name                   => $$run_dir_params{'run_name'},
                                                     lane                       => $lane,
                                                     full_path                  => $run_dir,
                                                     flow_cell_id               => $$run_dir_params{'flow_cell_id'},
                                                     sample_name                => $sample,
                                                     clusters                   => -1,
                                                     clusters_avg               => -1,
                                                     clusters_stdev             => -1,
                                                     filt_aligned_clusters_pct  => -1,
                                                     filt_aligned_clusters_stdev=> -1,
                                                     filt_clusters              => -1,
                                                     filt_clusters_avg          => -1,
                                                     filt_clusters_stdev        => -1,
                                                     filt_error_rate_avg        => -1,
                                                     filt_error_rate_stdev      => -1,
                                                     first_cycle_inten_avg      => -1,
                                                     first_cycle_inten_stdev    => -1,
                                                     inten_after_20_cycles_pct  => -1,
                                                     inten_after_20_cycles_stdev=> -1,
                                                     inten_avg                  => -1,
                                                     inten_stdev                => -1,
                                                     kilobases_read             => -1,
                                                     phasing_pct                => -1,
                                                     prephasing_pct             => -1,
                                                     read_length                => -1,
                                                     #seq_id                     => -1,
                                                     sral_id                    => -1,
                                                     library_name => 'TESTINGLIBRARY',
                                                 );
                my @files = grep { -e $_ } glob("$run_dir/${lane}_*.fastq");
                foreach my $file (@files){
                    $file =~ /sequence\.(.*)\.sorted/;
                    my $fs_path = GSC::SeqFPath->create(
                                                        path => $file ,
                                                        seq_id => $sls->seq_id,
                                                        data_type => $1  .' fastq path',
                                                        creation_event_id => -1,
                                                    );
                }
                push @read_sets, $sls;
            }
        }
    } else {
        die "Incorrect platform found $platform:  $!";
    }
    UR::Context->_sync_databases();
    return @read_sets;
}
