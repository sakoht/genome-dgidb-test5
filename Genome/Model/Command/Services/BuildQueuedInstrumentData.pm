#:boberkfe this  probably ought to be broken up so the build logic is moved out of the
#:boberkfe finding/create code

package Genome::Model::Command::Services::BuildQueuedInstrumentData;

use strict;
use warnings;

use Genome;

use GSCApp;

use Data::Dumper;

App::DB->db_access_level('rw');
App::DB::TableRow->use_dummy_autogenerated_ids(1);
App::DBI->no_commit(1);
App->init;


$ENV{UR_DBI_NO_COMMIT} = 1;
$ENV{UR_USE_DUMMY_AUTOGENERATED_IDS} = 1;


class Genome::Model::Command::Services::BuildQueuedInstrumentData {
    is  => 'Command',
    has => [
        test => {
            is => 'String',
            doc =>
"This parameter, if set true, will only process pses with negative id's, allowing your test to complete in a reasonable time frame.",
            is_optional => 1,
            default     => 0,
        }
    ],
};

sub help_brief {
'Find all QueueInstrumentDataForGenomeModeling PSEs, create appropriate models, assign instrument data, and finally trigger Build on the model';
}

sub help_synopsis {
    return <<'EOS'
EOS
}

sub help_detail {
    return <<EOS
EOS
}

sub execute {
    $DB::single = 1;
    my $self = shift;
    
    my $ps =
        GSC::ProcessStep->get(
            process_to => 'queue instrument data for genome modeling' );

    my @pses = GSC::PSE->get(
        ps_id      => $ps->ps_id,
        pse_status => 'inprogress',
    );
    
    my %models_with_new_instdata   = ( );
    my %models_with_found_instdata = ( );
    my %assign_all                 = ( );
    
  PSE: foreach my $pse (@pses) {
        
        my $pse_id = $pse->id();
        
        if ( $self->test ) {
            next if $pse_id > 0;
        }

        my ($instrument_data_type) = $pse->added_param('instrument_data_type');
        my ($instrument_data_id)   = $pse->added_param('instrument_data_id');
        my ($subject_class_name)   = $pse->added_param('subject_class_name');
        my ($subject_id)           = $pse->added_param('subject_id');
        

        my $subject      = $subject_class_name->get($subject_id);

        unless (defined$subject) {
            $self->error_message(
                'failed to get a subject via'
                . ' subject_class_name'
                . " '$subject_class_name'"
                . ' with subject_id'
                . " '$subject_id'"
            );
            next PSE;
        }

        my $subject_name = $subject->full_name();
        
        my @processing_profile_ids =
            $pse->added_param('processing_profile_id');

        unless ( 
                ( $instrument_data_type =~ /sanger/i )
                || 
                ( $instrument_data_type =~ /solexa/i )
                || 
                ( $instrument_data_type =~ /454/ ) 
            ) {
            
            self->error_message(
                'encountered unkown instrument data type'
                    . " '$instrument_data_type'");
                next PSE;
        }
        
        if ( $instrument_data_type =~ /sanger/i ) {
            
            my $pse = GSC::PSE::AnalyzeTraces->get($instrument_data_id);

            unless ( defined($pse) ) {
                $self->error_message(
                    'failed to fetch pse for sanger instrument data with'
                     . " id '$instrument_data_id'" 
                     . " and pse_id '$pse_id'"

                );
                next PSE;
            }

            my $run_name = $pse->run_name();

            unless ( defined($run_name) ) {
                $self->error_message(
                    'failed to get a run_name for sanger instrument data with'
                        . " id '$instrument_data_id'" 
                        . " and pse_id '$pse_id'" 
 

                );
                next PSE;
            }

            $instrument_data_id = $run_name;
            
        }

        my $genome_instrument_data =
            Genome::InstrumentData->get( id => $instrument_data_id );

        unless ( defined($genome_instrument_data) ) {
            
            $self->error_message(
                'Failed to get a Genome::InstrumentData via'
                . " id '$instrument_data_id' pse_id '$pse_id'");
            next PSE;
            
        }
        
        my @process_errors;
        
        #Loop 1
      PP: foreach my $processing_profile_id (@processing_profile_ids) {
            
            my $pp =
                Genome::ProcessingProfile->get(
                    id => $processing_profile_id );
            
            unless ($pp) {
                $self->error_message(
                    'Failed to get processing profile'
                    . " '$processing_profile_id' for inprogress pse "
                    . $pse->pse_id );
                push @process_errors, $self->error_message;
                next PP;
            }

            my $processing_profile_name = $pp->name();
            
            my @models = Genome::Model->get(
                subject_id            => $subject_id,
                subject_class_name    => $subject_class_name, 
                processing_profile_id => $pp->id,
                auto_assign_inst_data => 1,
            );
              
            # For Solexa Instrument Data, we don't want to (automagically)
            # assign capture and non-capture data to the same model.
            if ( $genome_instrument_data->can('target_region_set_name') ) {
                  
                my $id_capture_target =
                    $genome_instrument_data->target_region_set_name();                 
                
                my @inputs =
                    Genome::Model::Input->get(
                        model_id => [ map { $_->id } @models ], 
                        name => 'target_region_set_name',
                        value_id => $id_capture_target,
                    );

                @models = map { $_->model } @inputs;    
            }

            if (@models) {
              MODEL_IDA: foreach my $model (@models) {
                    
                    my @existing_instrument_data =
                        Genome::Model::InstrumentDataAssignment->get(
                            instrument_data_id => $instrument_data_id,
                            model_id           => $model->id,
                        );
                    
                    if (@existing_instrument_data) {
                        warn "instrument data '$instrument_data_id'"
                             . ' already assigned to model '
                             . "'"
                             . $model->id()
                             . "'";
                        $models_with_found_instdata{$model->id} = $model;
                        next MODEL_IDA;
                    }
                   
                    my $assign =
                        Genome::Model::Command::InstrumentData::Assign->create(
                            instrument_data_id => $instrument_data_id,
                            model_id           => $model->id,
                        );
                    
                    unless ( $assign->execute ) {
                        $self->error_message(
                            'Failed to execute instrument-data assign for '
                            . 'model '
                            . $model->id
                            . ' and instrument data '
                            . $instrument_data_id );
                        push @process_errors, $self->error_message;
                        next PP;
                    }

                    $models_with_new_instdata{$model->id} = $model;                        
                }
                
                next;
            }

            my $model_name = $subject_name . '.' . $pp->name;
            
            my $capture_target;

            # Label Solexa/454 capture stuff as such
            if ( $genome_instrument_data->can('target_region_set_name') ) {
                
                $capture_target =
                  $genome_instrument_data->target_region_set_name();
                
                if ( defined($capture_target) ) {
                    $model_name =
                        join( '.', $model_name, 'capture', $capture_target );
                }
                
            }

            # There may be a model with auto assign off already using the
            # default model name just determined above.  Thus this lame
            # attempt to create a unique name;
            my $name_counter = 0;
            
            my $existing_model = Genome::Model->get( name => $model_name );

            my $new_model_name;

            while ( defined($existing_model) ) {

                $name_counter++;
                
                $new_model_name = $model_name . '_auto' . $name_counter;
                $existing_model =
                    Genome::Model->get( name => $new_model_name );
            }
            
            if ( defined($new_model_name) ) {
                $model_name = $new_model_name;
            }

            my $model = Genome::Model->create(
                name                  => $model_name,
                subject_id            => $subject_id,
                subject_class_name    => $subject_class_name,
                processing_profile_id => $pp->id(),
                auto_assign_inst_data => 1,
            );


            unless ( defined($model) ) {
                $self->error_message(
                    "Failed to create model '$model_name'");
                push @process_errors, $self->error_message;
                next PP;
            }

            if ( defined($capture_target) ) {
                
                my $target_input = $model->add_input(
                    name             => "target_region_set_name",
                    value_class_name => "UR::Value",
                    value_id         => $capture_target
                );

les                unless ( defined($target_input) ) {
                    $self->error_message(
                            'Failed to set capture target input for model '
                          . $model->id
                          . ' and instrument data '
                          . $instrument_data_id );
                    push @process_errors, $self->error_message;
                    $model->delete();
                    next PP;
                }
                
                # By default the "region of interest" for analysis is the same
                # as the capture target in sequencing
                # 
                # Eventually the roi list / validation SNP list will be
                # looked up / validated here
                my $roi_input = $model->add_input(
                    name             => "region_of_interest_set_name",
                    value_class_name => "UR::Value", value_id => $capture_target
                  );
                
                unless (defined($roi_input)) {
                    $self->error_message('Failed to set region of instrument input for model '
                                         . $model->id
                                         . ' and instrument data '
                                         . $instrument_data_id);
                    push @process_errors, $self->error_message;
                    $model->delete();
                    next PP;
                }
                
            }
            
            my $assign_all =
                Genome::Model::Command::InstrumentData::Assign->create(
                    model_id => $model_id,
                    all      => 1,
                );
            
            unless ( $assign_all->execute ) {
                $self->error_message(
                    'Failed to execute instrument-data assign --all for model '
                    . $model_id );
                push @process_errors, $self->error_message;
                $model->delete();
                next PP;
            }

            #TODO: should we ensure that assign-all get the instdata we wanted???

            my @existing_instrument_data =
                Genome::Model::InstrumentDataAssignment->get(
                    instrument_data_id => $instrument_data_id,
                    model_id           => $model->id,
                );
            
            unless (@existing_instrument_data) {
                $self->error_message(
                    "instrument data '$instrument_data_id' already assigned to model ????? '" . $model->id() . "'"
                );
                push @process_errors, $self->error_message;
                $model->delete();
                next PP;
            }

        } # Loop 1
        
        # Loop 2: handle this instdata for other models besides the default
        {
            
            my $sequencing_platform = $instrument_data_type;
            
            # Mismatch between the valid values for a sequencing platform via
            # a processing profile and what is stored as the
            # instrument_data_type PSE param
            if ($sequencing_platform eq 'sanger') {
                $sequencing_platform = '3730';
            }

            my @found_models;
            my @check = qw/sample taxon/;

            for my $check (@check) {
                my $subject = $genome_instrument_data->$check;
                my @some_models= Genome::Model->get(
                    subject_id         => $subject->id,
                    subject_class_name => $subject->class,
                    auto_assign_inst_data => 1,
                );
                push @found_models,@some_models;
            }           
 
            @found_models =
                grep {
                    $_->processing_profile->can('sequencing_platform')
                } @found_models;

            @found_models =
                grep {
                    $_->processing_profile->sequencing_platform()
                        eq $sequencing_platform }
                    @found_models;
            
          FOUND_MODEL: foreach my $model (@found_models) {
                
                my @existing_assignments =
                    Genome::Model::InstrumentDataAssignment->get(
                        instrument_data_id => $instrument_data_id,
                        model_id           => $model->id,
                    );
                
                # Previous processing could have had problems, in which case
                # the instrument data might already be assigned.  This is not
                # something worth complaining about.
                if (@existing_assignments) {
                    $models_with_found_instdata{$model->id} = $model;                    
                    next FOUND_MODEL;
                }
                
                my $assign =
                    Genome::Model::Command::InstrumentData::Assign->create(
                        instrument_data_id => $instrument_data_id,
                        model_id           => $model->id,
                    );
                
                unless ( $assign->execute ) {
                    $self->error_message(
                        'Failed to execute instrument-data assign for'
                        . ' model '
                        . $model->id
                        . ' and instrument data '
                        . $instrument_data_id );
                        
                    push @process_errors, $self->error_message;
                    
                    next FOUND_MODEL;

                }
                
                $models_with_new_instdata{$model->id} = $model;               
            }
            
        } #Loop 2
        
        
        if ( @process_errors > 0 ) {
            $self->error_message(
                "Leaving queue instrument data PSE inprogress, due to errors. \n"
                    . join "\n",
                @process_errors
            );
        }
        else {
            
            # Set the pse as completed since this is the end of the line
            # for the pses
            $pse->pse_status("completed");
        }
        
    }
    
    #UR::Context->commit();
    
    UR::Context->rollback();   
    
    my %definitely_build = (%assign_all, %models_with_new_instdata);
    my %possibly_build = (%models_with_found_instdata); # TODO don't include the above

    for my $model (values %possibly_build) {
        my @builds = $model->builds;
        my $last_build = $builds[-1];
        my @inputs = $last_build->inputs;
        my @assignments= $model->instrument_data_assignments;
        # @assignments > @inputs? add to the list of definitely build 
        
    }
       
    for my $model_id (sort keys %definitely_build) {
        my $model = Genome::Model->get($model_id); 
        eval {
            Genome::Model::Build::Command::Start->execute(
                model_identifier => $model_id,
                force            => 1,
            ) or die 'Failed to start a build for model ' . $model_id;
        };
    
        if ($@) {
            warn $@;
            UR::Context->rollback();
            next MODEL;
        }
        
        #UR::Context->commit();
    }
    
    return 1;
    
}

1;
