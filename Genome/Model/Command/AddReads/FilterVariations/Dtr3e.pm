package Genome::Model::Command::AddReads::FilterVariations::Dtr3e;

use strict;
use warnings;
use above "Genome";
use Genome::Model::Command::AddReads::FilterVariations::Filters::ScaledBinomialTest;
use FileHandle;


####################################
#THIS IS THE NEW VERSION--DAVE LARSON WROTE IT
#CHRIS HARRIS REFACTORED IT
#IT EXPECTS DAVE LARSONS VERSION OF PP OUTPUT
####################################

class Genome::Model::Command::AddReads::FilterVariations::Dtr3e {
    is => ['Genome::Model::Command::AddReads::FilterVariations'],
    sub_classification_method_name => 'class',
    has => [ ]
};

sub sub_command_sort_position { 90 }

sub help_brief {
    "Create filtered lists of variations."
}

sub help_synopsis {
    return <<"EOS"
    genome-model postprocess-alignments filter-variations --model-id 5 --ref-seq-id 22 
EOS
}

sub help_detail {
    return <<"EOS"
    Create filtered list(s) of variations.
EOS
}

sub command_subclassing_model_property {
    "filter_ruleset_name"
}



sub execute {
    my $self=shift;
    my $model = $self->model;

    my $qvalue_level;
    my $bq;
 
    ###undo previous times we did stuff for this event######
    unless($self->revert) {
        $self->error_message("There was a problem reverting the previous iterations changes.");
        return;
    }

    
    #this file should be the output of the annotate step for our chromosome
    my $file=$self->variation_metrics_file_name;

    unless( -f $file) {
        $self->error_message("Experimental PP output doesn't seem to be a real file: $file (where's our input?");
        return;
    }


    my ($filtered_list_dir) = $model->_filtered_variants_dir();
    $self->status_message("Filtered variants directory is $filtered_list_dir");
    unless (-d $filtered_list_dir) {
        mkdir $filtered_list_dir;
        `chmod g+w $filtered_list_dir`;
    }

    #so this '$basename' variable basically specifies full dir and prefix for most of the files generated by this step (not including the metric code)
    my $basename= $model->_filtered_variants_dir() . '/filtered.';
    my $specificity='default';
    #end object data gathering---



    #begin complex mg crap 
    my %specificity_maqq = (
        min => [ 5, 16 ],
        default => [ 30, 16 ],
        90 => [ 40, 22 ],
        95 => [ 50, 26 ],
        max => [ 120, 26 ],
    );


    my $spec_ref = (exists($specificity_maqq{$specificity})) ?
    $specificity_maqq{$specificity} : $specificity_maqq{default};
    ($qvalue_level, $bq) = @$spec_ref;
    $qvalue_level ||= 30;
    $bq ||= 16;


    #left over from being a command line script....
    #croak "dtr_split -input [filename] -basename [filename]\n"
    #    unless(defined($file) && defined($basename));      




    my $handle = new FileHandle;
    $handle->open($file, "r") or die "Couldn't open annotation file\n";

    my $header_line = $handle->getline; #store header
    my $keep_handle = new FileHandle;
    my $remove_handle = new FileHandle;
    my $keep_file = $basename . 'chr' . $self->ref_seq_id . '.keep.csv';
    my $remove_file = $basename . 'chr' . $self->ref_seq_id . '.remove.csv';
    $keep_handle->open("$keep_file","w") or die "Couldn't open keep output file\n";
    $remove_handle->open("$remove_file","w") or die "Couldn't open remove output file\n";

    chomp $header_line;
    print $keep_handle $header_line . ", rule\n";
    print $remove_handle $header_line . ", rule\n";


    my %result;
    #print new header
    while(my $line=$handle->getline) {
        chomp $line;
        $line =~ s/NULL/0/g;
        next if $line =~ /^chromosome/;    
        my ($chr,$position,$al1,$al2,$qvalue,$al2_read_hg,$avg_map_quality,$max_map_quality,$n_max_map_quality,$avg_sum_of_mismatches,$max_sum_of_mismatches,$n_max_sum_of_mismatches, $base_quality, $max_base_quality, $n_max_base_quality, $avg_windowed_quality, $max_windowed_quality, $n_max_windowed_quality, $for_strand_unique_by_start_site, $rev_strand_unique_by_start_site, $al2_read_unique_dna_context, $for_strand_unique_by_start_site_pre27,$rev_strand_unique_by_start_site_pre27,$al2_read_unique_dna_context_pre27) = split ", ", $line;
        my $al2_read_unique_dna_start = $for_strand_unique_by_start_site + $rev_strand_unique_by_start_site;
        my $al2_read_unique_dna_start_pre27 = $for_strand_unique_by_start_site_pre27 + $rev_strand_unique_by_start_site_pre27;
        
        next if $qvalue < 15; #hardcoded to make this work, filtering out anything that is not q 15
        
        my $decision = 'keep';
        my $rule = 'none';
        
        if ($al2_read_unique_dna_start > 7 && $qvalue >= $qvalue_level) {
            #Rule 5:
            #    	# of unique genomic reads supporting variant allele(starting point) > 7
            #	->  class G  [96.8%]
            #
            $decision = 'keep';
            $rule = '5';
        #} elsif ($al2_read_unique_dna_start > 2 && $base_quality <= $bq + 2) {
        #   #Rule 2:
        #   # of unique genomic reads supporting variant allele(starting point) > 2
        #   #    	Base Quality > 18
        #   #	->  class G  [90.7%]
        #   #
        #   $decision = 'keep';
        #   $rule = '2';
        } elsif ($max_base_quality <= 26) {
            #Rule 11:
            #    	Max Base Quality <= 26
            #	->  class WT  [85.2%]
            #
            $decision = 'remove';
            $rule = '11';
        } elsif ($al2_read_unique_dna_start <= 7 && $qvalue < $qvalue_level) {
            #Rule 7:
            #    	# of unique genomic reads supporting variant allele(starting point) <= 7
            #    	Maq SNP q-value <= 29
            #	->  class WT  [81.5%]
            #
            $decision = 'remove';
            $rule = '7';
        } elsif ($al2_read_unique_dna_start <= 2) {
            #Rule 8:
            #    	# of unique genomic reads supporting variant allele(starting point) <= 2
            #	->  class WT  [74.7%]
            #
            $decision = 'remove';
            $rule = '8';
        } elsif ($base_quality <= $bq) {
            #Rule 3:
            #    	Base Quality <= 16
            #	->  class WT  [73.0%]
            #
            $decision = 'remove';
            $rule = '3';
        } else {
            #Default class: G
            $decision = 'keep';
            $rule = 'default';
        }

        ##additional arbitrary filter on pre-27 readcounts
        unless($al2_read_unique_dna_start_pre27 > 2) {
            $decision = 'remove';
            $rule = 'pre-27';
        }

        #        my $variant_detail = Genome::VariantReviewDetail->get(
        #            chromosome => $chr, 
        #            begin_position => $position, 
        #            end_position => $position,
        #            insert_sequence_allele1 => $al2,
        #            delete_sequence => $al1,
        #        );
        #        my $validation;
        #        if(!defined($variant_detail)) {
        #            #try and see if it was a biallelic variant site
        #            $variant_detail = Genome::VariantReviewDetail->get(
        #                chromosome => $chr, 
        #                begin_position => $position, 
        #                end_position => $position,
        #                insert_sequence_allele2 => $al2,
        #                delete_sequence => $al1,
        #            );
        #        }
        #        if(defined($variant_detail)) {
        #            #it's been sent to manual review
        #            my $decision = $variant_detail->pass_manual_review; 
        #            #if there is a somatic status then it probably
        #            #passed manual review but wasn't documented.
        #            #Or it was directly passed along.
        #            $validation = $variant_detail->somatic_status;
        #            $validation ||= '0';
        #        }
        #        else {
        #            $validation = 'NONE';
        #        }
        #        
        #		$result{$decision}{$validation}{n} += 1;
        #		$result{$decision}{$validation}{rule}{$rule} += 1;
        
        if ($decision eq 'keep') {
            print $keep_handle $line,", $rule\n";    
        }  else {
            print $remove_handle $line,", $rule\n";    
        }
    }

    $keep_handle->close();
    $remove_handle->close();
    $handle->close();

    my $basename_for_binomial = $model->_filtered_variants_dir . "/binomial.chr" . $self->ref_seq_id;

    ###Begin scaled binomial test launch.
    my @params = (
        experimental_metric_model_file=> $keep_file,   
        experimental_metric_normal_file=>$self->normal_sample_variation_metrics_file,
        binomial_test_basename => $basename_for_binomial, 
        ref_seq_id => $self->ref_seq_id
    );
    $self->status_message("params for binomial test:" . Data::Dumper::Dumper(\@params));
    my $rv = Genome::Model::Command::AddReads::FilterVariations::Filters::ScaledBinomialTest->execute(@params);

    #this needs to operate on the output of scaled binomial test.
    $self->generate_figure_3_files($basename_for_binomial . '.nonskin.csv');
}


sub variation_metrics_file_name {
    my $self = shift;
    my $library_name = shift;

    my $annotate_step = Genome::Model::Event->get(parent_event_id => $self->parent_event_id, ref_seq_id => $self->ref_seq_id, "event_type like" => '%annotate%');
    my $post_process_step= Genome::Model::Event->get(parent_event_id => $self->parent_event_id, ref_seq_id => $self->ref_seq_id, "event_type like" => '%postprocess-variations%');

    my $base_variation_file_name = $post_process_step->experimental_variation_metrics_file_basename . ".csv";

    unless($library_name) {
        return $base_variation_file_name;
    }
    return "$base_variation_file_name.$library_name";
} 

sub generate_figure_3_files {
    my $self = shift;  
    my $somatic_file=shift;

    #this might break
    my $prior = Genome::Model::Event->get(id => $self->prior_event);
    my $snp_file = $prior->snp_report_file;
    #end possible break
    
    #Hash for ranking somatic statuses
    my %rank = ('S' => 0,
        'G' => 1,
        'WT' => 2,
        'A' => 3,
        'V' => 3,
        'O' => 3,
        'LQ' => 4,
        'X' => 4,
        'NC' => 5,
    );
    #END HASH
    
    #my $snp_file = $self->_report_file('snp');
        my $dir = $self->model->_filtered_variants_dir();
        if(!defined($dir)) {
            $self->error_message("No filtered_variants directory returned.");
            return undef;
        }
       my $dbsnp_fh = IO::File->new(">$dir" . "/somatic_variants_in_d_v_w_" . $self->ref_seq_id .
            ".csv");
       my $dbsnp_count=0;      
       my $non_coding_fh = IO::File->new(">$dir" .
           "/non_coding_tumor_only_variants_" . $self->ref_seq_id .
            ".csv");
       my $non_coding_count=0;      
       my $novel_tumor_fh = IO::File->new(">$dir" .
           "/novel_tumor_only_variants_" . $self->ref_seq_id .
            ".csv");
       my $novel_tumor_count=0;      
       my $silent_fh = IO::File->new(">$dir" .
           "/silent_tumor_only_variants_" . $self->ref_seq_id .
            ".csv");
       my $silent_count=0;     
       my $nonsynonymous_fh = IO::File->new(">$dir" .
           "/non_synonymous_splice_site_variants_" . $self->ref_seq_id .
            ".csv");
       my $nonsynonymous_count=0;      
       my $var_never_manreview_fh = IO::File->new(">$dir" .
           "/var_never_manreview_" . $self->ref_seq_id . ".csv");
       my $never_manreview_count=0;
       my $var_pass_manreview_fh = IO::File->new(">$dir" .
           "/var_pass_manreview_" . $self->ref_seq_id .
            ".csv");
       my $var_pass_manreview_count=0;     
       my $var_fail_manreview_fh = IO::File->new(">$dir" .
           "/var_fail_manreview_" . $self->ref_seq_id .
            ".csv");
       my $var_fail_manreview_count=0;     
       my $var_fail_valid_assay_fh = IO::File->new(">$dir" .
           "/var_fail_valid_assay_" . $self->ref_seq_id .
            ".csv");
       my $var_fail_valid_assay_count=0;      
       my $var_complete_validation_fh = IO::File->new(">$dir" .
           "/var_complete_validation_" . $self->ref_seq_id .
            ".csv");
       my $var_complete_validation_count=0;      
       my $validated_snps_fh = IO::File->new(">$dir" .
           "/validated_snps_" . $self->ref_seq_id .
            ".csv");
       my $validated_snps_count=0;     
       my $false_positives_fh = IO::File->new(">$dir" .
           "/false_positives_" . $self->ref_seq_id .
            ".csv");
       my $false_positives_count=0;     
       my $validated_somatic_var_fh = IO::File->new(">$dir" .
           "/validated_somatic_variants_" . $self->ref_seq_id .
            ".csv");
       my $validated_somatic_var_count=0;     
        #added to track things that were passed through manual review but
        #don't have a validation status. Could be pending or could be missing
        #from db
       my $passed_but_no_status_count=0;     
       my $passed_but_no_status_fh = IO::File->new(">$dir" .
           "/var_pass_manreview_but_no_val_status_" . $self->ref_seq_id .
            ".csv");
         my $annotation_fh = IO::File->new($snp_file);
        if(!defined($annotation_fh)) {
            $self->error_message("Could not open report file.");
            return undef;
        }
        my $somatic_fh = IO::File->new($somatic_file);
        if(!defined($somatic_fh)) {
            $self->error_message("Could not open file of somatic mutations.");
            return undef;
        }
        my @cur_somatic_snp;
        my @cur_anno_snp;
        my $anno_line;
        my $somatic_line;
        #throw away header
        $somatic_fh->getline;
        #throw away the header, but preload anno_line so our loop gets off the ground. i rate this hack:medium special
        $anno_line = $annotation_fh->getline;
        #end throw away header section
      while(($somatic_line=$somatic_fh->getline) && defined $anno_line) {
          chomp $somatic_line;
          if (!defined $somatic_line || !defined $anno_line) {
              #the filter file must be over if we're here
              last;
              
          }
          @cur_somatic_snp = split(/,\s+/, $somatic_line);
          
          while(!@cur_anno_snp || ($cur_anno_snp[1] < $cur_somatic_snp[1]) ) {
              #we hit this block because a) this is our first time through
              #or b) the last annotation position is smaller than the current somatic snp
              # snp value   
              $anno_line = $annotation_fh->getline;
              chomp $anno_line;
              if(!defined $anno_line) {
                  $self->error_message("Annotation file has ended before somatic file. This may be ok.");
                  $self->error_message("Last somatic snp was\n " . join (" ", @cur_somatic_snp) . "last anno snp was\n " . join(" ", @cur_anno_snp) );
                  last;
              }
              @cur_anno_snp= split (/,/, $anno_line);
          } 
          while($cur_anno_snp[1] == $cur_somatic_snp[1] ) {
          #if we get here then the idea is we have a somatic line with the same position as a snp line.
     
             #call in Brian's somatic file and Eddie's report

             #For Eddie's output we need to know the type of variant and also the
             #dbSNP and Watson/Venter status
             my @report_indexes = (0,1,2,3,5,8,13,18,19,20); 

             #this is taken care of implicitly by the loop actually...damn pair programming
             if(defined($cur_somatic_snp[0]) && defined($cur_anno_snp[0])) {
                 #it's genic and in Eddie's report and passed Brian's filters
                 my ($chromosome, $begin, $end,
                     $variant_allele, $reference_allele, $gene, $variant_type,$dbsnp,
                     $watson, $venter) = @cur_anno_snp[@report_indexes];    

                 #Test if seen in dbSNP or Watson/Venter
                 if((defined($dbsnp) && $dbsnp ne '0') || (defined($watson) && $watson ne '0' ) || (defined($venter) && $venter ne '0')) {
                     #previously identified
                     $self->_write_array_to_file(\@cur_anno_snp, $dbsnp_fh);
                     $dbsnp_count++;
                 }
                 else {
                     $self->_write_array_to_file(\@cur_anno_snp,
                         $novel_tumor_fh);    
                     $novel_tumor_count++;    
                     #nonsynonymous
                     if( $variant_type =~ /missense|nonsense|nonstop|splice_site/i) {
                         #output those that are coding
                         $self->_write_array_to_file(\@cur_anno_snp,
                             $nonsynonymous_fh);
                             $nonsynonymous_count++;

                         my $variant_detail = Genome::VariantReviewDetail->get(
                             chromosome => $chromosome, 
                             begin_position => $begin, 
                             end_position => $end,
                             insert_sequence_allele1 => $variant_allele,
                             delete_sequence => $reference_allele,
                         );
                         if(!defined($variant_detail)) {
                             #try and see if it was a biallelic variant site
                             $variant_detail = Genome::VariantReviewDetail->get(
                                 chromosome => $chromosome, 
                                 begin_position => $begin, 
                                 end_position => $end,
                                 insert_sequence_allele2 => $variant_allele,
                                 delete_sequence => $reference_allele,
                             );
                         }
                         if(defined($variant_detail)) {
                             #it's been sent to manual review
                             my $decision = $variant_detail->pass_manual_review; 
                             #if there is a somatic status then it probably
                             #passed manual review but wasn't documented.
                             #Or it was directly passed along.
                             my $db_status = $variant_detail->somatic_status;
                             my $status;
                             #take care of the possibility of discrepancy
                             my ($level1_discrep) = $db_status =~ /^DISCREPANCY\((.*)/;
                             my $level2_discrep;
                             if(defined($level1_discrep)) {
                                 ($level2_discrep) = $level1_discrep =~ /^DISCREPANCY\((.*)/;
                             }
                             if(defined($level2_discrep)) {
                                 my @status = split /:/, $level2_discrep;
                                 map {s/^\s*(\S*)\s*$/$1/} @status;
                                 my $new_status = 'NC';
                                 foreach my $discr_status (@status) {
                                     if($rank{$discr_status} < $rank{$new_status} ) {
                                         $new_status = $discr_status;
                                     }
                                 }
                                 $status = $new_status;
                             }
                             elsif(defined($level1_discrep)) {
                                 my @status = split /:/, $level1_discrep;
                                 map {s/^\s*(\S*)\s*$/$1/} @status;
                                 my $new_status = 'NC';
                                 foreach my $discr_status (@status) {
                                     unless(defined($rank{$discr_status})) {
                                         $self->error_message("No entry for |$discr_status|");
                                     }
                                     if($rank{$discr_status} < $rank{$new_status} ) {
                                         $new_status = $discr_status;
                                     }
                                 }
                                 $status = $new_status;
                             }
                             else {
                                 $status = $db_status;
                             }


                             if(defined($decision) && lc($decision) eq 'yes'
                                 || defined($status)) {
                                 $self->_write_array_to_file(\@cur_anno_snp,
                                     $var_pass_manreview_fh);
                                 $var_pass_manreview_count++;

                                 if(defined($status)) {
                                     $status = uc($status);
                                     if($status eq 'S') {
                                         $self->_write_array_to_file(\@cur_anno_snp,
                                             $validated_somatic_var_fh);
                                         $validated_somatic_var_count++;
                                     }
                                     elsif($status eq 'WT') {
                                         $self->_write_array_to_file(\@cur_anno_snp,
                                             $false_positives_fh);
                                         $false_positives_count++;
                                     }
                                     elsif($status eq 'G') {
                                         $self->_write_array_to_file(\@cur_anno_snp,
                                             $validated_snps_fh);
                                         $validated_snps_count++;
                                     }
                                     else {
                                         $self->_write_array_to_file(\@cur_anno_snp, $var_fail_valid_assay_fh);
                                         $var_fail_valid_assay_count++;
                                     }

                                 }
                                 else {
                                     #else no validation status
                                     $passed_but_no_status_count++;     
                                     $self->_write_array_to_file(\@cur_anno_snp, $passed_but_no_status_fh);  
                                 }


                             }
                             else {
                                 #TODO This may not be valid if for instance
                                 #maybe's were passed along to validation
                                 $self->_write_array_to_file(\@cur_anno_snp,
                                     $var_fail_manreview_fh);
                                 $var_fail_manreview_count++;
                             }

                         }
                         else {
                             #we're actually not tracking this case in the
                             #figure
                             #Not in database, but should be!
                             #Either novel or missing from database
                             $never_manreview_count++;
                             $self->_write_array_to_file(\@cur_anno_snp,
                                 $var_never_manreview_fh);
                         }

                     }
                     elsif( $variant_type eq 'silent') {
                         $self->_write_array_to_file(\@cur_anno_snp,
                             $silent_fh);
                             $silent_count++;
                     }
                     else {
                         $self->_write_array_to_file(\@cur_anno_snp,
                             $non_coding_fh);
                             $non_coding_count++;
                     }
                 }
             }

       
     
             $anno_line = $annotation_fh->getline;
             chomp $anno_line;
              if(!defined $anno_line) {
                  #annotation file has ended before somatic one has...this is bad
                  $self->error_message("Annotation file has ended before somatic file. This is probably bad.\n");
                  $self->error_message("Last somatic snp was\n " . @cur_somatic_snp . "last anno snp was\n " . @cur_anno_snp );
                  last;
              }
              @cur_anno_snp= split (/,/, $anno_line);
             
          }
      }
      #close all filehandles.
      my $metric;
      $metric = $self->add_metric(
                                    name=> "somatic_variants_in_d_v_w",
                                    value=> $dbsnp_count,
                                );

      $metric = $self->add_metric(
                                    name=> "non_coding_tumor_only_variants",
                                    value=> $non_coding_count,
                                );


      $metric = $self->add_metric(
                                    name=> "novel_tumor_only_variants",
                                    value=> $novel_tumor_count,
                                );


      $metric = $self->add_metric(
                                    name=> "silent_tumor_only_variants",
                                    value=> $silent_count,
                                );
      $metric = $self->add_metric(
                                    name=> "non_synonymous_splice_site_variants",
                                    value=> $nonsynonymous_count,
                                );


     $metric = $self->add_metric(
                                    name=> "var_pass_manreview",
                                    value=> $var_pass_manreview_count,
                                );


     $metric = $self->add_metric(
                                    name=> "var_fail_manreview",
                                    value=> $var_fail_manreview_count,
                                );
     $metric = $self->add_metric(
                                    name=> "var_fail_valid_assay",
                                    value=> $var_fail_valid_assay_count,
                                );
    $metric = $self->add_metric(
                                    name=> "var_complete_validation",
                                    value=> $var_complete_validation_count,
                                );

    $metric = $self->add_metric(
                                    name=> "validated_snps",
                                    value=> $validated_snps_count,
                                );
    $metric = $self->add_metric(
                                    name=> "false_positives",
                                    value=> $false_positives_count,
                                );
    $metric = $self->add_metric(
                                    name=> "validated_somatic_variants",
                                    value=> $validated_somatic_var_count,
                                );
    $metric = $self->add_metric(
                                    name=> "var_never_sent_to_manual_review",
                                    value=> $never_manreview_count,
                                );
    $metric = $self->add_metric(
                                    name=> "var_pass_manreview_but_no_val_status",
                                    value=> $passed_but_no_status_count,
                                );





      $dbsnp_fh->close;
      $non_coding_fh->close;
      $novel_tumor_fh->close;
      $silent_fh->close;
      $nonsynonymous_fh->close;
      $var_pass_manreview_fh->close;
      $var_fail_manreview_fh->close;
      $var_fail_valid_assay_fh->close;
      $var_complete_validation_fh->close;
      $validated_snps_fh->close;
      $false_positives_fh->close;
      $validated_somatic_var_fh->close;
      $annotation_fh->close;
      $somatic_fh->close;

  }

sub _write_array_to_file {
    my $self=shift;
    my $array_ref_to_write=shift;
    my $file_handle=shift;

    my $line_to_write = join (" ", @{$array_ref_to_write});
    $file_handle->print($line_to_write . "\n");

    return 1;
}
    

sub somatic_variants_in_d_v_w {
    my $self = shift;
    my $name = 'somatic_variants_in_d_v_w';
    return $self->get_metric_value($name);
}

sub non_coding_tumor_only_variants {
    my $self = shift;
    my $name = 'non_coding_tumor_only_variants';
    return $self->get_metric_value($name);
}
sub novel_tumor_only_variants {
    my $self = shift;
    my $name = 'novel_tumor_only_variants';
    return $self->get_metric_value($name);
}


sub silent_tumor_only_variants {
    my $self = shift;
    my $name = 'silent_tumor_only_variants';
    return $self->get_metric_value($name);
}

sub non_synonymous_splice_site_variants {
    my $self = shift;
    my $name = 'non_synonymous_splice_site_variants';
    return $self->get_metric_value($name);
}

sub var_pass_manreview {
    my $self = shift;
    my $name = 'var_pass_manreview';
    return $self->get_metric_value($name);
}

sub var_fail_manreview {
    my $self = shift;
    my $name = 'var_fail_manreview';
    return $self->get_metric_value($name);
}


sub var_fail_valid_assay {
    my $self = shift;
    my $name = 'var_fail_valid_assay';
    return $self->get_metric_value($name);
}


sub var_complete_validation {
    my $self = shift;
    my $name = 'var_complete_validation';
    return $self->get_metric_value($name);
}

sub validated_snps {
    my $self = shift;
    my $name = 'validated_snps';
    return $self->get_metric_value($name);
}
sub false_positives {
    my $self = shift;
    my $name = 'false_positives';
    return $self->get_metric_value($name);
}
sub validated_somatic_variants {
    my $self = shift;
    my $name = 'validated_somatic_variants';
    return $self->get_metric_value($name);
}

sub _calculate_somatic_variants_in_d_v_w {
    my $self = shift;
    my $name = 'somatic_variants_in_d_v_w';
    return $self->get_metric_value($name);
}

sub _calculate_non_coding_tumor_only_variants {
    my $self = shift;
    my $name = 'non_coding_tumor_only_variants';
    return $self->get_metric_value($name);
}
sub _calculate_novel_tumor_only_variants {
    my $self = shift;
    my $name = 'novel_tumor_only_variants';
    return $self->get_metric_value($name);
}


sub _calculate_silent_tumor_only_variants {
    my $self = shift;
    my $name = 'silent_tumor_only_variants';
    return $self->get_metric_value($name);
}

sub _calculate_non_synonymous_splice_site_variants {
    my $self = shift;
    my $name = 'non_synonymous_splice_site_variants';
    return $self->get_metric_value($name);
}

sub _calculate_var_pass_manreview {
    my $self = shift;
    my $name = 'var_pass_manreview';
    return $self->get_metric_value($name);
}

sub _calculate_var_fail_manreview {
    my $self = shift;
    my $name = 'var_fail_manreview';
    return $self->get_metric_value($name);
}


sub _calculate_var_fail_valid_assay {
    my $self = shift;
    my $name = 'var_fail_valid_assay';
    return $self->get_metric_value($name);
}


sub _calculate_var_complete_validation {
    my $self = shift;
    my $name = 'var_complete_validation';
    return $self->get_metric_value($name);
}

sub _calculate_validated_snps {
    my $self = shift;
    my $name = 'validated_snps';
    return $self->get_metric_value($name);
}
sub _calculate_false_positives {
    my $self = shift;
    my $name = 'false_positives';
    return $self->get_metric_value($name);
}
sub _calculate_validated_somatic_variants {
    my $self = shift;
    my $name = 'validated_somatic_variants';
    return $self->get_metric_value($name);
}

sub tumor_only_variants {
    my $self = shift;
    my $name = 'tumor_only_variants';
    return $self->get_metric_value($name);
}
sub skin_variants {
    my $self = shift;
    my $name = 'skin_variants';
    return $self->get_metric_value($name);
}

sub well_supported_variants {
    my $self = shift;
    my $name = 'well_supported_variants';
     return $self->get_metric_value($name);
 }

sub _calculate_well_supported_variants {
    my $self = shift;
    my $file_I_will_wordcount_to_find_total_variants = $self->keep_file_name;
    my $file_wordcount_1  = `wc -l $file_I_will_wordcount_to_find_total_variants | cut -f1 -d' '`;
    chomp($file_wordcount_1);
    return $file_wordcount_1;
 }


sub _calculate_tumor_only_variants {
    my $self = shift;
    my $file_I_will_wordcount_to_find_only_tumor_variants = $self->somatic_file_name;
    my $file_wordcount = `wc -l $file_I_will_wordcount_to_find_only_tumor_variants | cut -f1 -d' '`;
    chomp($file_wordcount);
    return $file_wordcount;
}
sub _calculate_skin_variants {
    my $self = shift;
    my $file_I_will_wordcount_to_find_total_variants = $self->keep_file_name;
    my $file_I_will_wordcount_to_find_only_tumor_variants = $self->somatic_file_name;
    my $file_wordcount_1  = `wc -l $file_I_will_wordcount_to_find_total_variants | cut -f1 -d' '`;
    my $file_wordcount_2  = `wc -l $file_I_will_wordcount_to_find_only_tumor_variants | cut -f1 -d' '`;
    chomp($file_wordcount_1);
    chomp($file_wordcount_2);    
    return $file_wordcount_1 - $file_wordcount_2;
}

sub somatic_file_name {
    my $self=shift;
    my $model = $self->model;
    return  $model->_filtered_variants_dir() . "/filtered.chr" . $self->ref_seq_id . '.somatic.csv';
}

sub keep_file_name {
    my $self=shift;
    my $model = $self->model;
    return  $model->_filtered_variants_dir() . "/filtered.chr" . $self->ref_seq_id . '.keep.csv';
}
sub remove_file_name {
    my $self=shift;
    my $model = $self->model;
    return  $model->_filtered_variants_dir() . "/filtered.chr" . $self->ref_seq_id . '.remove.csv';
}

sub report_file_name {
    my $self=shift;
    my $model = $self->model;
    return  $model->_filtered_variants_dir() . "/filtered.chr" . $self->ref_seq_id . '.report.csv';
}

sub invalue_file_name {
    my $self=shift;
    my $model = $self->model;
    return  $model->_filtered_variants_dir() . "/filtered.chr" . $self->ref_seq_id . '.invalue.csv';
}

sub metrics_for_class {
    my $self = shift;
    my @metrics = qw| 
    somatic_variants_in_d_v_w
    non_coding_tumor_only_variants
    novel_tumor_only_variants
    silent_tumor_only_variants
    non_synonymous_splice_site_variants
    var_pass_manreview
    var_fail_manreview
    var_fail_valid_assay
    var_complete_validation
    validated_snps
    false_positives
    validated_somatic_variants
    skin_variants
    tumor_only_variants 
    well_supported_variants
    |;
}


sub normal_sample_variation_metrics_file {
    my $self= shift;
    my $model = $self->model;

    my $model_name = $model->name;
    my $normal_name = $model_name;

    $normal_name =~ s/98tumor/34skin/g;
    my $normal_model = Genome::Model->get('name like' => $normal_name);
    unless ($normal_model) {
        $self->error_message(sprintf("normal model matching name %s does not exist.  please verify this first.", $normal_name));
        return undef;
    }

# Get metrics for the normal sample for processing.
my $latest_normal_build = $normal_model->latest_build_event;
unless ($latest_normal_build) {
    $self->error_message("Failed to find a build event for the comparable normal model " . $normal_model->name);
    return;
}

my ($equivalent_skin_event) =
grep { $_->isa("Genome::Model::Command::AddReads::PostprocessVariations")  }
$latest_normal_build->child_events(
    ref_seq_id => $self->ref_seq_id
);

unless ($equivalent_skin_event) {
    $self->error_message("Failed to find an event on the skin model to match the tumor.  Probably need to re-run after that completes.  In the future, we will have the tumor/skin filtering separate from the individual model processing.\n");
    return;
}
my $normal_sample_variation_metrics_file_name =  $equivalent_skin_event->experimental_variation_metrics_file_basename . ".csv";

unless (-e $normal_sample_variation_metrics_file_name) {
    $self->error_message("Failed to find variation metrics for \"normal\": $normal_sample_variation_metrics_file_name");
    return;
}
return $normal_sample_variation_metrics_file_name

}




















#my $keep_wt = 0;
#my $total_wt = 0;
#my $keep_g = 0;
#my $total_g = 0;
#foreach my $type (sort (keys %result)) {
#	print $report_handle "$type\n";
#	foreach my $status (sort (keys %{$result{$type}})) {
#		my $n = $result{$type}{$status}{n};
#		if ($status eq 'WT') {
#			$total_wt += $n;
#			if ($type eq 'remove') {
#				$keep_wt += $n;
#			}
#		}
#		if ($status eq 'G') {
#			$total_g += $n;
#			if ($type eq 'keep') {
#				$keep_g += $n;
#			}
#		}
#		my @rules;
#		foreach my $rule (sort (keys %{$result{$type}{$status}{rule}})) {
#			push @rules, (join(':',($rule, $result{$type}{$status}{rule}{$rule})));
#		}
#		print $report_handle "\t" . 
#			join("\t",($status,$n,join(',',@rules))) . "\n";
#	}
#}
#if ($total_wt > 0) {
#	printf $report_handle "Specificity: %0.2f\n", (100.0 * ($keep_wt/$total_wt));
#}
#if ($total_g > 0) {
#	printf $report_handle "Sensitivity: %0.2f\n", (100.0 * ($keep_g/$total_g));
#}


#C4.5 [release 8] rule generator	Thu May 22 14:52:58 2008
#-------------------------------
#
#    Options:
#	Rulesets evaluated on unseen cases
#	File stem <training>
#
#Read 149 cases (40 attributes) from training
#
#Composite ruleset:
#
#Rule 5:
#    	# of unique genomic reads supporting variant allele(starting point) > 7
#	->  class G  [96.8%]
#
#Rule 2:
#    	# of unique genomic reads supporting variant allele(starting point) > 2
#    	Base Quality > 18
#	->  class G  [90.7%]
#
#Rule 11:
#    	Max Base Quality <= 26
#	->  class WT  [85.2%]
#
#Rule 7:
#    	# of unique genomic reads supporting variant allele(starting point) <= 7
#    	Maq SNP q-value <= 29
#	->  class WT  [81.5%]
#
#Rule 8:
#    	# of unique genomic reads supporting variant allele(starting point) <= 2
#	->  class WT  [74.7%]
#
#Rule 3:
#    	Base Quality <= 16
#	->  class WT  [73.0%]
#
#Default class: G
#
#Composite ruleset:
#
#Rule  Size  Error  Used  Wrong	          Advantage
#----  ----  -----  ----  -----	          ---------
#   5     1   3.2%    42      0 (0.0%)	     0 (0|0) 	G
#   2     2   9.3%    52      6 (11.5%)	    -3 (1|4) 	G
#  11     1  14.8%    16      1 (6.2%)	     3 (3|0) 	WT
#   7     2  18.5%     9      1 (11.1%)	     2 (2|0) 	WT
#   8     1  25.3%    17      4 (23.5%)	     9 (12|3) 	WT
#   3     1  27.0%     7      2 (28.6%)	     3 (5|2) 	WT
#
#Drop rule 2
#
#Rule  Size  Error  Used  Wrong	          Advantage
#----  ----  -----  ----  -----	          ---------
#   5     1   3.2%    42      0 (0.0%)	     0 (0|0) 	G
#  11     1  14.8%    17      1 (5.9%)	     4 (4|0) 	WT
#   7     2  18.5%    13      2 (15.4%)	     4 (5|1) 	WT
#   8     1  25.3%    17      4 (23.5%)	     9 (12|3) 	WT
#   3     1  27.0%     7      2 (28.6%)	     3 (5|2) 	WT
#
#Tested 149, errors 13 (8.7%)   <<
#
#
#	  (a)  (b)	<-classified as
#	 ---- ----
#	   45    4	(a): class WT
#	    9   91	(b): class G
#
#
#Trial   Size      Errors
#-----   ----      ------
#   0       4   17(11.4%)
#   1       5   20(13.4%)
#   2       4   18(12.1%)
#  **       5   13( 8.7%)
#				Av size = 4.5,  av errors = 17.0 (11.4%)
#
#Composite ruleset:
#
#Rule  Size  Error  Used  Wrong	          Advantage
#----  ----  -----  ----  -----	          ---------
#   5     1   3.2%   152     22 (14.5%)	    -2 (4|6) 	G
#  11     1  14.8%   142      1 (0.7%)	     4 (4|0) 	WT
#   7     2  18.5%    49      3 (6.1%)	    18 (19|1) 	WT
#   8     1  25.3%   170      7 (4.1%)	   154 (161|7) 	WT
#   3     1  27.0%    36      5 (13.9%)	    26 (31|5) 	WT
#
#Tested 666, errors 95 (14.3%)   <<
#
#
#	  (a)  (b)	<-classified as
#	 ---- ----
#	  381   79	(a): class WT
#	   16  190	(b): class G
#
#
#Trial   Size      Errors
#-----   ----      ------
#   0       4   88(13.2%)
#   1       5  107(16.1%)
#   2       4  120(18.0%)
#  **       5   95(14.3%)
#				Av size = 4.5,  av errors = 102.5 (15.4%)
#
