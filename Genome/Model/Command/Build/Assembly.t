#!/gsc/bin/perl

use strict;
use warnings;

use above "Genome";
use Test::More;
use File::Path;


$ENV{UR_DBI_NO_COMMIT} = 1;
$ENV{UR_USE_DUMMY_AUTOGENERATED_IDS} = 1;

BEGIN {
    my $archos = `uname -a`;
    if ($archos !~ /64/) {
        plan skip_all => "Must run from 64-bit machine";
    }
    plan tests => 293;
    use_ok( 'Genome::RunChunk::454');
    use_ok( 'Genome::Model::Assembly');
    use_ok( 'Genome::ProcessingProfile::Assembly');
    use_ok( 'Genome::Model::Command::Create::Model' );
    use_ok( 'Genome::Model::Command::Create::ProcessingProfile' );
    use_ok( 'Genome::Model::Command::Create::ProcessingProfile::Assembly' );
    use_ok( 'Genome::Model::Command::Build::Assembly' );
    use_ok( 'Genome::Model::Command::Build::Assembly::AssignReadSetToModel' );
    use_ok( 'Genome::Model::Command::Build::Assembly::AssignReadSetToModel::454' );
    use_ok( 'Genome::Model::Command::Build::Assembly::FilterReadSet' );
    use_ok( 'Genome::Model::Command::Build::Assembly::FilterReadSet::Seqclean' );
    use_ok( 'Genome::Model::Command::Build::Assembly::TrimReadSet' );
    use_ok( 'Genome::Model::Command::Build::Assembly::TrimReadSet::Sfffile' );
    use_ok( 'Genome::Model::Command::Build::Assembly::AddReadSetToProject' );
    use_ok( 'Genome::Model::Command::Build::Assembly::AddReadSetToProject::Newbler' );
    use_ok( 'Genome::Model::Command::Build::Assembly::Assemble' );
    use_ok( 'Genome::Model::Command::Build::Assembly::Assemble::Newbler' );
};

my %pp_1_params = (
                 name => 'test_assembly_processing_profile_1',
                 assembler_name => 'newbler',
                 assembler_params => '-a 0',
                 read_filter_name => 'seqclean',
                 read_trimmer_name => 'sfffile',
                 sequencing_platform => '454',
             );

my %pp_2_params = (
                 name => 'test_assembly_processing_profile_2',
                 assembler_name => 'newbler',
                 assembler_params => '-a 0',
                 sequencing_platform => '454',
             );
my @pp_params = (\%pp_1_params,\%pp_2_params);

my $model_name = 'test_assembly_model';
my $subject_name = 'TSP_Round1-4_Normal_Amplicon_Pool';

for my $pp_params (@pp_params) {
    my %pp_params = %{$pp_params};
    my $pp = Genome::ProcessingProfile::Assembly->create(%pp_params);

    ok($pp, 'creation worked assembly processing profile');
    isa_ok($pp ,'Genome::ProcessingProfile::Assembly');
    for my $key (keys %pp_params) {
        is($pp->$key,$pp_params{$key},"$key accessor");
    }
    my $model = Genome::Model::Assembly->create(
                                                processing_profile_id => $pp->id,
                                                name => $model_name,
                                                subject_name => $subject_name,
                                            );
    isa_ok($model,'Genome::Model::Assembly');
    is($model->subject_name,$subject_name,'subject_name accessor');
    is($model->name,$model_name,'name accessor');
    my $add_reads_command = Genome::Model::Command::AddReads->create(
                                                                     model_id => $model->id,
                                                                     all => 1,
                                                                 );
    isa_ok($add_reads_command,'Genome::Model::Command::AddReads');

    &_trap_messages($add_reads_command);

    ok($add_reads_command->execute(),'execute genome-model add-reads');

    my @status_messages = $add_reads_command->status_messages();
    ok(scalar(@status_messages), 'add-reads execute printed some status messages');
    ok(scalar(grep { $_ eq 'Adding all available reads to the model...!'} @status_messages), 'execute mentioned it was adding all reads');
    ok(scalar(grep { $_ eq 'Found 8 compatible read sets.' } @status_messages), 'execute mentioned it found 8 read seta');
    my @warning_messages = $add_reads_command->warning_messages();
    is(scalar(@warning_messages), 0, 'execute generated no warning messages');
    my @error_messages = $add_reads_command->error_messages();
    is(scalar(@error_messages), 0, 'execute generated no error messages');
    

    my $assembly_builder = Genome::Model::Command::Build::Assembly->create(
                                                                           model_id => $model->id,
                                                                           auto_execute => 0,
                                                                       );
    isa_ok($assembly_builder,'Genome::Model::Command::Build::Assembly');

    &_trap_messages($assembly_builder);

    ok($assembly_builder->execute,'execute assembly builder');

    @status_messages = $assembly_builder->status_messages();
    # Each execute generates a message per ReadSet, plus 4 more for the build's 4 sub-steps (5 total)
    # so for 8 ReadSets = 8 * 5 = 40
    # plus 2 more for scheduling reference sequence / Build::Assembly::Assemble
    #is(scalar(@status_messages), 42, 'executing builder generated 42 messages');
    for(my $i = 0; $i < 8; $i++) {
        is($status_messages[0], 'Scheduling for Genome::Model::ReadSet', 'Found scheduling ReadSet messages');
        like($status_messages[1], qr(^Scheduled Genome::Model::Command::Build::Assembly::AssignReadSetToModel),
             'Found Scheduled...AssignReadSetToModel message');
        if ($pp_params->{'read_filter_name'}) {
            like($status_messages[2], qr(^Scheduled Genome::Model::Command::Build::Assembly::FilterReadSet),
                 'Found Scheduled...FilterReadSet messages');
        } else {
            is($status_messages[2], 
               "No value defined for subclassing model property 'read_filter_name'.  Skipping 'Genome::Model::Command::Build::Assembly::FilterReadSet'",
               'Message correctly indicates that it is skipping FilterReadSet');
        }

        if ($pp_params->{'read_trimmer_name'}) {
            like($status_messages[3], qr(^Scheduled Genome::Model::Command::Build::Assembly::TrimReadSet),
                 'Found Scheduled...TrimReadSet messages');
        } else {
            is($status_messages[3], 
               "No value defined for subclassing model property 'read_trimmer_name'.  Skipping 'Genome::Model::Command::Build::Assembly::TrimReadSet'",
               'Message correctly indicates that it is skipping TrimReadSet');
        }
        like($status_messages[4], qr(^Scheduled Genome::Model::Command::Build::Assembly::AddReadSetToProject),
             'Found Scheduled...AddReadSetToProject messages');
        splice(@status_messages, 0, 5);
    }
    is($status_messages[0], 'Scheduling for reference_sequence', 'Found reference_sequence message');
    like($status_messages[1], qr(^Scheduled Genome::Model::Command::Build::Assembly::Assemble),
        'Found Build Assembly message');
    

    @warning_messages = $assembly_builder->warning_messages;
    is(scalar(@warning_messages), 0, 'executing builder generated no warming messages');
    @error_messages = $assembly_builder->error_messages;
    is(scalar(@error_messages), 0, 'executing builder generated no error messages');

    for my $class ($assembly_builder->stage1_job_classes) {
        my @events = $class->get(model_id => $model->id);
        for my $event (@events) {

            &_trap_messages($event);

            # Executing AddReadSetToProject events runs an external program that can
            # print to stdout.  It's failure is properly caught by the caller, so we're
            # not bothering to make sure the message is correct
            my $foo = &_disable_std_out_err();
            my $rv = $event->execute();
            &_enable_std_out_err($foo);
            
            ok($rv,"execute $class event");

            @warning_messages = $assembly_builder->warning_messages;
            is(scalar(@warning_messages), 0, 'event execution produced no warning messages');
            @error_messages = $assembly_builder->error_messages;
            is(scalar(@error_messages), 0, 'event execution produced no error messages');
        }
    }
    my @assemble_events = Genome::Model::Command::Build::Assembly::Assemble->get(model_id => $model->id);
    is(scalar(@assemble_events),1,'one assemble event for project');
    my $assemble = $assemble_events[0];
    isa_ok($assemble,'Genome::Model::Command::Build::Assembly::Assemble');
  SKIP: {
        skip "assemble takes a long time", 1;
        ok($assemble->execute,'execute assemble project');
    }
    rmtree($model->data_directory);
}
exit;



sub _trap_messages {
    my $obj = shift;

    $obj->dump_error_messages(0);
    $obj->dump_warning_messages(0);
    $obj->dump_status_messages(0);
    $obj->queue_error_messages(1);
    $obj->queue_warning_messages(1);
    $obj->queue_status_messages(1);
}


# Returns a "token" that can be used later to re-enable them
sub _disable_std_out_err {
    open my $oldout, ">&STDOUT"     or die "Can't dup STDOUT: $!";
    open my $olderr, ">&", \*STDERR or die "Can't dup STDERR: $!";

    open(STDOUT,'>/dev/null');
    open(STDERR,'>/dev/null');

    return { oldout => $oldout, olderr => $olderr };
}

sub _enable_std_out_err {
    my $oldout = $_[0]->{'oldout'};
    my $olderr = $_[0]->{'olderr'};

    open STDOUT, ">&", $oldout or die "Can't dup \$oldout: $!";
    open STDERR, ">&", $olderr or die "Can't dup \$olderr: $!";
}
