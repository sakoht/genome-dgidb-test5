package Genome::Model::Command::Build::ReferenceAlignment::Solexa;

use strict;
use warnings;
use Genome;

class Genome::Model::Command::Build::ReferenceAlignment::Solexa {
    is => 'Genome::Model::Command::Build::ReferenceAlignment',
    has => [],
    has => [
        model_id    => {
            is => 'Integer', 
            doc => 'Identifies the genome model to which we\'ll add the reads.'
        },
        testing_flag => {
            is => 'Integer',
            doc =>'When set to 1, turns off automatic RunJobsing...',
            is_optional=>1,
            default=>0,
        },
      
        #  data_directory =>{
            #    is => 'String',
            #    is_calculated => 1,
            #       calculate => q| return $self->model->data_directory |,
            #     } 
            
    ],

 };

sub sub_command_sort_position { 40 }

sub help_brief {
    "postprocess any alignments generated by a model which have not yet been added to the full assembly"
}

sub help_synopsis {
    return <<"EOS"
genome-model build mymodel 
EOS
}

sub help_detail {
    return <<"EOS"
One build of a given reference-alignment model.
EOS
}   
 

sub backend_job_classes {
    my @step1 =  ('Genome::Model::Command::AddReads::MergeAlignments');
    my @step2 =  ('Genome::Model::Command::AddReads::UpdateGenotype');
    my @step3 =  ('Genome::Model::Command::AddReads::FindVariations'),
    my @step4 =  ('Genome::Model::Command::AddReads::PostprocessVariations', 'Genome::Model::Command::AddReads::AnnotateVariations');
    
    return (\@step1, \@step2, \@step3, \@step4);
}

sub execute {
    my $self = shift;
    $DB::single = 1;
    my @undone_or_failed_read_sets = $self->find_unaligned_or_failed_read_sets();
    $self->data_directory($self->model->data_directory);
    #subroutine: find undone sets...if 0, don't call 'addreads' modules...
    if(@undone_or_failed_read_sets) {
        #TODO: Make this status message print out flowcell/lane
        $self->status_message("Found these readsets unaligned:\n" . join ("\n", map {$_->read_set_id } @undone_or_failed_read_sets)); 
        $self->schedule_frontend(@undone_or_failed_read_sets);
        #bsub helper will set 'waiting status' if you return 2
        return 2;
    }
    elsif (my @events = Genome::Model::Event->get(parent_event_id=>$self->id, ref_seq_id => { operator => "ne", value =>undef} ) ) {
        #we have events for the backend;
        if(grep (/Failed|Crashed/, @events)) {
            #Genome::Model::Command::RunJobs->execute(model_id=> $self->model_id);
            $self->status_message("Some events failed. Failing the build.");
            return;
        }
        else { 
            return 1;
        }
    }
    else {
        $self->status_message(  "No unaligned found\n" . "Starting the backend...");
     
        unless($self->schedule_backend()) {
            $self->error_message("problems building, exiting..");
            return;
        }   
        return 2; 
    }
    ##need third condition of backend completed set me successful
    return 1; 
}

sub extend_last_execution {
    my ($self) = @_;

    # like execute, but get the existing steps, see which ones never got executed, and generates those.

    my @sub_command_classes = $self->subordinate_job_classes;

    my $model = Genome::Model->get($self->model_id);
    my @subreferences_names = grep {$_ ne "all_sequences" } $model->get_subreference_names(reference_extension=>'bfa');

    unless (@subreferences_names > 0) {
        @subreferences_names = ('all_sequences');
    }

    my @new_events;    
    foreach my $ref (@subreferences_names) { 
        my $prior_event_id = undef;
        foreach my $command_class ( @sub_command_classes ) {
            my $command = $command_class->get(
                model_id => $self->model_id, 
                ref_seq_id => $ref,
                parent_event_id => $self->id,
            );

            unless ($command) {
                $command = $command_class->create(
                    model_id => $self->model_id, 
                    ref_seq_id=>$ref,
                    prior_event_id => $prior_event_id,
                    parent_event_id => $self->id,
                );
                unless ($command) {
                    die "Failed to create command object: $command_class!" . $command_class->error_message;
                }
                push @new_events, $command;
                $command->parent_event_id($self->id);
                $command->event_status('Scheduled');
                $command->retry_count(0);
            }

            $prior_event_id = $command->id;
        }
    }

    return @new_events; 
}

sub _get_sub_command_class_name{
  return __PACKAGE__; 
}

sub find_unaligned_or_failed_read_sets {
    my $self=shift;
    my $model = $self->model;
    my @readsets_that_need_rescheduling;
    $DB::single=1;
    my @undone_model_readsets  = 
    Genome::Model::ReadSet->get(model_id=> $model->id , first_build_id=>undef);
        push(@readsets_that_need_rescheduling, @undone_model_readsets);

    my @attempted_or_successful_model_readsets = 
    Genome::Model::ReadSet->get(model_id=> $model->id , first_build_id=> {operator => 'ne', value=>undef});
     for my $attempted_readset (@attempted_or_successful_model_readsets) {
        my @events = Genome::Model::Event->get(model_id=>$model->id, 
        run_id=>$attempted_readset->read_set_id);

        if(my @broke_events = grep {$_->event_status =~ /Crashed|Failed/} @events ) {
            push(@readsets_that_need_rescheduling, $attempted_readset);
        }

    }
    return @readsets_that_need_rescheduling;
}

sub schedule_backend {
    #FIXME: Do this more elegantly in the class def?
    my $self=shift;
    unless( -d $self->data_directory) {
        unless(mkdir $self->data_directory ) {
            $self->error_message("Unable to create dir: " . $self->data_directory);
            return;
        }
        chmod 02775, $self->data_directory;
    } 
    my @sub_command_classes = $self->backend_job_classes;

    my $model = Genome::Model->get($self->model_id);
    $self->status_message("Found Model: " . $model->name);
    my @subreferences_names = grep {$_ ne "all_sequences" } $model->get_subreference_names(reference_extension=>'bfa');

    unless (@subreferences_names > 0) {
        @subreferences_names = ('all_sequences');
    }
    my @classes_I_am_waiting_for;
    foreach my $ref (@subreferences_names) {
        $self->status_message("Scheduling for subreference: $ref"); 
        my $prior_event_id = undef;
        foreach my $command_classes ( @sub_command_classes ) {

            my $command;
            for my $command_class (@{$command_classes}) {  
                $command = $command_class->create(
                    model_id => $self->model_id, 
                    ref_seq_id=>$ref,
                    prior_event_id => $prior_event_id,
                    parent_event_id => $self->id,
                );
                $command->parent_event_id($self->id);
                $command->event_status('Scheduled');
                $command->retry_count(0);
            }
            #clearly this will not work well if the pipeline wanted to come back together after a fork...
            #don't cry about it if it happens
            $prior_event_id = $command->id;
            push @classes_I_am_waiting_for, $command;
        }
    }
    unless($self->testing_flag) {
        Genome::Model::Command::RunJobs->execute(model_id=> $self->model_id);
        ###now its time to run myself with the correct dependencies on a blade!
        my @dependencies = map {$_->lsf_job_id} @classes_I_am_waiting_for;
        #rofl...stretched this bsub implementation far beyond the breaking point
        unless($self->execute_with_bsub(dep_type=>'ended' , dependency_expression => join(")&&ended(", @dependencies)) )
        {
            $self->status_message("Hello, I am the build::referencealignment module, and I was unable to schedule myself to run after my peeps.");
            return;
        } 
    }

    return 1;
}


sub schedule_frontend {
    my $self = shift;
    my @readsets_to_schedule=@_;
    my $model = $self->model;

    my @sub_command_classes = $self->frontend_job_classes(); 

    my @classes_I_am_waiting_for;
    $DB::single=1;
    for my $read_set (@readsets_to_schedule) {

            my $prior_event_id = undef;
      
        foreach my $command_class ( @sub_command_classes ) {
            my $command;
    
            eval {
                $command = $command_class->create(
                    run_id => $read_set->read_set_id,
                    model_id => $self->model_id,
                    event_status => 'Scheduled',
                    retry_count => 0,
                    prior_event_id => $prior_event_id,
                    parent_event_id => $self->id,
                );
            };
            unless ($command) {
                $DB::single = $DB::stopper;
                $command = $command_class->create(
                    run_id => $read_set->read_set_id,
                    model_id => $self->model_id,
                    event_status => 'Scheduled',
                    retry_count => 0,
                    prior_event_id => $prior_event_id,
                    parent_event_id => $self->id,
                );
                
                $self->error_message(
                    "Problem creating subcommand for class $command_class run id " .$read_set->read_set_id
                    . " model id ".$self->model_id
                    . ": " . $command_class->error_message()
                );
                return;
            }
            push @classes_I_am_waiting_for, $command;
            $self->status_message('Scheduled '. $command_class .' for run_id '. $read_set->read_set_id
                                  .' event_id '. $command->genome_model_event_id ."\n");
                     $prior_event_id = $command->id;
        }
        
    }
    unless($self->testing_flag) {
        Genome::Model::Command::RunJobs->execute(model_id=> $self->model_id);
        ###now its time to run myself with the correct dependencies on a blade!
        my @dependencies = map {$_->lsf_job_id} @classes_I_am_waiting_for;
        unless($self->execute_with_bsub(dep_type=>'ended' , dependency_expression => join(")&&ended(", @dependencies) ) )
        {
            $self->status_message("Hello, I am the build::referencealignment module, and I was unable to schedule myself to run after my peeps.");
            return;
        } 
    }
    return 1; 
}

sub frontend_job_classes {
    my $self = shift;

    my @sub_command_classes= qw/
        Genome::Model::Command::AddReads::AssignRun
        Genome::Model::Command::AddReads::AlignReads
        Genome::Model::Command::AddReads::ProcessLowQualityAlignments
    /;

    return @sub_command_classes;
}


1;

