package Genome::Model::Command::Build::Status;

use strict;
use warnings;
use Genome;
use Data::Dumper;
use XML::LibXML;

class Genome::Model::Command::Build::Status {
    is => ['Command'],
    has => [ 
            build_id => { 
                is => 'String', 
                doc => 'Required id of build to report status on.',
            },
            build   => {
                is => 'Genome::Model::Build',
                id_by => 'build_id',
                doc => "The Build of a genome model to report status on.",
            },
    ],
    has_optional => [
            section => {
                is => 'String',
                doc => "NOT IMPLEMENTED YET.  The sub-section of the document to return.  Options are 'all', 'events', etc.", 
            }, 
            display_output => {
                is => 'Integer',
                default_value => 1,
                doc => "A flag which lets the user supress the display of XML output to the screen.", 
            }, 
            use_lsf_file => {
                is => 'Integer',
                default_value => 0,
                doc => "A flag which lets the user retrieve LSF status from a temporary file rather than using a bjobs command to retrieve the values.", 
            }, 
            _doc => {
                  is => 'XML::LibXML::Document',
                  doc => "The XML tool used to create all nodes of the output XML tree.",
            },
            _xml => {
                  is => 'Text',
                  doc => "The XML generated by the status call.",
            },
            _job_to_status => {
                  is => 'HASH',
                  doc => "The XML generated by the status call.",
            },


   ],
    
};

sub execute  {
    my $self = shift;
    my $return_value = 1;

    #create _job_to_status hash
    if ($self->use_lsf_file) {
        my %job_status_hash = $self->load_lsf_job_status();
        $self->_job_to_status(\%job_status_hash);
    }
   
    #create the XML doc and add it to the object 
    my $doc = XML::LibXML->createDocument();
    $self->_doc($doc);

    #create the xml nodes and fill them up with data
    #root node
    my $build_status_node = $doc->createElement("build-status");
    my $time = UR::Time->now(); 
    $build_status_node->addChild( $doc->createAttribute("generated-at",$time) );
  
    #build node 
    my $buildnode = $self->get_build_node;
    $build_status_node->addChild($buildnode);
   
    #processing profile 
    $buildnode->addChild ( $self->get_processing_profile_node() );
    
    #TODO:  add method to build for logs, reports
    #$buildnode->addChild ( $self->tnode("logs","") );
    $buildnode->addChild ( $self->get_reports_node );

    #set the build status node to be the root
    $doc->setDocumentElement($build_status_node); 

    #generate the XML string
    $self->_xml($doc->toString(1) );

    #print to the screen if desired
    if ( $self->display_output ) {
        print $self->_xml;
    } 

    return $return_value;
}

sub xml {
    my $self = shift;
    return $self->_xml;
}

sub get_reports_node {
    my $self = shift;

    my $report_dir = $self->build->resolve_reports_directory;
    my $reports_node = $self->anode("reports", "directory", $report_dir);
    my @report_list = $self->build->reports;
    for my $each_report (@report_list) {
        my $report_node = $self->anode("report","name", $each_report->name );
        $self->add_attribute($report_node, "subdirectory", $each_report->name_to_subdirectory($each_report->name) );
        $reports_node->addChild($report_node); 
    }

    return $reports_node;
 

}

sub get_events_node {
    my $self = shift;
    my $doc = $self->_doc;

    my $events_list = $doc->createElement("events");
    my @events = $self->build->events;

    for my $event (@events) {
        my $event_node = $self->get_event_node($event);
        $events_list->addChild($event_node);
    }

    return $events_list;

}

sub get_build_node {
    my $self = shift;
    my $doc = $self->_doc;
    
    my $buildnode = $doc->createElement("build");

    my $model = $self->build->model;

    $buildnode->addChild( $doc->createAttribute("model-name",$model->name) );
    $buildnode->addChild( $doc->createAttribute("model-id",$model->id) );
    $buildnode->addChild( $doc->createAttribute("build-id",$self->build_id) );
    $buildnode->addChild( $doc->createAttribute("status",$self->build->build_status) );
    $buildnode->addChild( $doc->createAttribute("data-directory",$self->build->data_directory) );
 
    return $buildnode; 
}

#Note:  Since the Web server cannot execute bjob commands, use the cron'd results from the tmp file
sub load_lsf_job_status {
    my $self = shift;

    my %job_to_status;
    my $lsf_file = '/gsc/var/cache/testsuite/lsf-tmp/bjob_query_result.txt';
    my @bjobs_lines = IO::File->new($lsf_file)->getlines;
    shift(@bjobs_lines);
    for my $bjob_line (@bjobs_lines) {
        my @job = split(/\s+/,$bjob_line);
        $job_to_status{$job[0]} = $job[2];
    }
    return %job_to_status;
}

sub get_processing_profile_node {

    my $self = shift;
    my $model = $self->build->model;
    my $doc = $self->_doc;

    my $pp = $model->processing_profile;
    my $pp_name = $pp->name;
    
    my $stages_node = $self->anode("stages","processing_profile",$pp_name);
    
    for my $stage_name ($pp->stages) {
        my $stage_node = $self->anode("stage","value",$stage_name);
        my $commands_node = $doc->createElement("command_classes"); 
        my $operating_on_node = $doc->createElement("operating_on"); 
        
        my @objects = $pp->objects_for_stage($stage_name,$model);
        foreach my $object (@objects) {
    
            my $object_node;
 
            #if we have a full blown object (REF), get the object data 
            if ( ref(\$object) eq "REF" ) {
                if ( $object->class eq "Genome::InstrumentData::Solexa" ) {
                    my $id_node = $self->get_instrument_data_node($object); 
                    $object_node = $self->anode("object","value","instrument_data");
                    $object_node->addChild($id_node); 
                }
            } else {
                 $object_node = $self->anode("object","value",$object);          
            }
            
            $operating_on_node->addChild($object_node); 
        } 

        my @command_classes = $pp->classes_for_stage($stage_name);
        foreach my $classes (@command_classes) {
            #$commands_node->addChild( $self->anode("command_class","value",$classes ) );
            my $command_node =  $self->anode("command_class","value",$classes );
            #get the events for each command class
            $command_node->addChild($self->get_events_for_class_node($classes));  
            $commands_node->addChild( $command_node );
        }
        $stage_node->addChild($commands_node);
        $stage_node->addChild($operating_on_node);
        $stages_node->addChild($stage_node);
    }

    return $stages_node;
}

sub get_events_for_class_node {
    my $self = shift;
    my $class = shift;
    my $doc = $self->_doc;

    my $events_list_node = $doc->createElement("events");
    my @events = $class->get( model_id => $self->build->model->id, build_id => $self->build->build_id);

    for my $event (@events) {
        my $event_node = $self->get_event_node($event);
        $events_list_node->addChild($event_node);
    }

    return $events_list_node;

}



sub get_instrument_data_node {
  
    my $self = shift;
    my $object = shift; 

    #print Dumper($object);

    my $id = $self->anode("instrument_data","id",$object->id);
    $id->addChild( $self->tnode("project_name",$object->project_name)); 
    $id->addChild( $self->tnode("sample_name",$object->sample_name)); 
    $id->addChild( $self->tnode("run_name",$object->run_name) );
    $id->addChild( $self->tnode("flow_cell_id",$object->flow_cell_id) );
    $id->addChild( $self->tnode("read_length",$object->read_length) );
    $id->addChild( $self->tnode("library_name",$object->library_name) );
    $id->addChild( $self->tnode("library_id",$object->library_id) );
    $id->addChild( $self->tnode("lane",$object->lane));
    $id->addChild( $self->tnode("subset_name",$object->subset_name));
    $id->addChild( $self->tnode("seq_id",$object->seq_id));
    $id->addChild( $self->tnode("run_type",$object->run_type));
    $id->addChild( $self->tnode("gerald_directory",$object->gerald_directory));
                    
    return $id;

}

sub get_lsf_job_status {
    my $self = shift;
    my $lsf_job_id = shift;

    my $result;
 
    if ( defined($lsf_job_id) ) { 

        #check the user specified flag to determine how to retrieve lsf status
        if ($self->use_lsf_file) {
            #get the data from the preloaded hash of lsf info (from file)
            my %job_to_status = %{$self->_job_to_status}; 
            $result = $job_to_status {$lsf_job_id};
            if (!defined($result) ) {
                $result = "UNAVAILABLE";
            } 
        } else { 
            #get the data directly from lsf via bjobs command 
            my @lines = `bjobs $lsf_job_id`; 
            #parse the bjobs output.  get the 3rd field of the 2nd line.
            if ( (scalar(@lines)) > 1) { 
                my $line = $lines[1]; 
                my @fields = split(" ",$line); 
                $result = $fields[2];
            } else {
                #if there are no results from bjobs, lsf forgot about the job already.
                $result = "UNAVAILABLE";
            }
        }

    } else {
        #if the input LSF ID is not defined, mark it as unscheduled.
        $result = "UNSCHEDULED";
    }
    return $result;

    #NOTES:  UNSCHEDULED means that an LSF ID exists, but LSF did not have any status on it.  Probably because it was executed a while ago.
    #        UNAVAILABLE means that an LSF ID does NOT exist.
}

sub get_event_node {
    
    my $self = shift; 
    my $event = shift;
    my $doc = $self->_doc;

    my $lsf_job_status = $self->get_lsf_job_status($event->lsf_job_id);

    my $event_node = $self->anode("event","id",$event->id);
    $event_node->addChild( $doc->createAttribute("command_class",$event->class)); 
        $event_node->addChild( $self->tnode("event_status",$event->event_status));
        $event_node->addChild( $self->tnode("lsf_job_id",$event->lsf_job_id));
        $event_node->addChild( $self->tnode("lsf_job_status",$lsf_job_status));
        $event_node->addChild( $self->tnode("date_scheduled",$event->date_scheduled));
        $event_node->addChild( $self->tnode("date_completed",$event->date_completed));
        $event_node->addChild( $self->tnode("elapsed_time", $self->calculate_elapsed_time($event->date_scheduled,$event->date_completed) ));
        $event_node->addChild( $self->tnode("instrument_data_id",$event->instrument_data_id));
        my $log_file = $event->resolve_log_directory ."/".$event->id.".err";
        $event_node->addChild( $self->tnode("log_file",$log_file));
    return $event_node;

}

 sub create_node_with_attribute {
   
    my $self = shift;
    my $node_name = shift;
    my $attr_name = shift;
    my $attr_value = shift;

    my $doc = $self->_doc;
    
    my $node = $doc->createElement($node_name);
    $node->addChild($doc->createAttribute($attr_name,$attr_value));
    return $node;

} 

#helper methods.  just pass through to the more descriptive names 
#anode = attribute node
sub anode {
    my $self = shift;
    return $self->create_node_with_attribute(@_);
}
 
#tnode = text node
sub tnode {
    my $self = shift; 
    return $self->create_node_with_text(@_);
}
 
sub create_node_with_text {
 
    my $self = shift;
    my $node_name = shift;
    my $node_value = shift;

    my $doc = $self->_doc;
    
    my $node = $doc->createElement($node_name);
    if ( defined($node_value) ) {
        $node->addChild($doc->createTextNode($node_value));
    } 
    return $node;

} 

sub add_attribute {
    my $self = shift;
    my $node = shift;
    my $attr_name = shift;
    my $attr_value = shift;

    my $doc = $self->_doc;

    $node->addChild($doc->createAttribute($attr_name,$attr_value) );
    return $node;

}

sub calculate_elapsed_time {
    my $self = shift;
    my $date_scheduled = shift;
    my $date_completed = shift;

    my $diff;

    if ($date_completed) {
        $diff = UR::Time->datetime_to_time($date_completed) - UR::Time->datetime_to_time($date_scheduled);
    } else {
        $diff = time - UR::Time->datetime_to_time( $date_scheduled);
    }

    my $m = int($diff/60);
    my $s = $diff % 60;
    return "${m}m ${s}s" if $m;
    return "${s}s";
}





1;

