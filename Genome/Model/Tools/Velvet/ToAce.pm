package Genome::Model::Tools::Velvet::ToAce;

use strict;
use warnings;

use Genome;
use IO::File;
use Tie::File;
use Bio::SeqIO;
use Date::Format;
use AMOS::AmosLib;
use File::Basename;

use GSC::IO::Assembly::Ace::Writer;

#Notes from Feiyu (Mar 2009):
#velvet 7.30 change RED id naming for iid(internal) and eid(external): eid = iid + 1, so iid is 0-based and eid is 1-based.
#Sequences file lists reads 0-based.
#Pcap names scaffold 0-based, while contig 1-based.
#Original velvet_asm.afg file names scaffold 1-based, while it names contig 0-based. This tool will convert to pcap scaffold/contig naming
#In afg file's TLE field, src lists read's iid(0-based) not eid(1-based).
#contigs.fa is actually supercontig/scaffold fasta for recent velvet version so it is 1-based.

#velvet 7.44 RED id naming: iid = eid and is 1-based. TLE field src points to RED iid/eid (now same). Sequences file generated by 
#velveth now is using the real read name instead of silly index id.


class Genome::Model::Tools::Velvet::ToAce {
    is           => 'Command',
    has          => [
        afg_file    => {
            is      => 'String', 
            doc     => 'input velvet_asm.afg file path',
        }
    ],
    has_optional => [
        out_acefile => {
            is      => 'String', 
            doc     => 'name for output acefile, default is ./velvet_asm.ace',
            default => 'velvet_asm.ace',
        },
        seq_file  => {
            is      => 'String', 
            doc     => 'path name for Sequences file generated by velveth. Actual read names (not index id) will be used in acefile with this index. Default is to use Sequences file in the same directory as afg_file',
        },
        time        => {
            is      => 'String',
            doc     => 'timestamp inside acefile, must be sync with phd timestamp',
        },
    ],
};
        

sub help_brief {
    "This tool converts velvet output velvet_asm.afg into acefile format",
}


sub help_synopsis {
    return <<"EOS"
gt velvet to-ace --afg-file velvet_asm.afg [--out-acefile acefile_name]
EOS
}


sub help_detail {
    return <<EOS
If give "-amos_file yes" option to run velvetg, velvet will generate velvet_asm.afg 
file that contains all contigs/reads assembly/alignment info. This tool will convert 
those info into acefile so assembly can be viewed/edited by using consed.
EOS
}


sub create {
    my $class = shift;
    my $self  = $class->SUPER::create(@_);

    my $file = $self->afg_file;    
    unless (-s $file and $file =~ /\.afg/) {
        $self->error_message("Input velvet afg file: $file must NOT be valid or existing");
        return;
    }    
         
    my $seq_file = $self->seq_file;
    unless ($seq_file and -s $seq_file) {
        $seq_file = (dirname $file) . '/Sequences';
        unless (-s $seq_file) {
            $self->error_message("Failed to find valid Sequences file to be index");
            return;
        }
        $self->seq_file($seq_file);
    }
        
    my $out_file = $self->out_acefile;
    $self->warning_message("out_acefile: $out_file exists and will be overwritten") 
        if -s $out_file;
        
    return $self;
}


sub execute {
    my $self = shift;
    
    my $time   = $self->time || localtime;
    my $out    = IO::File->new('>'.$self->out_acefile) or die "can't write to out_acefile\n";
    my $writer = GSC::IO::Assembly::Ace::Writer->new($out);

    my $seqinfo  = {};
    my $nReads   = 0;
    my $nContigs = 0;

    #velvet 7.44 uses the actual read name as the fasta header in Sequences file
    my $io = Bio::SeqIO->new(-format => 'fasta', -file => $self->seq_file);
    my $ct = 0;
        
    #%seqinfo is 1-based.
    while (my $seq = $io->next_seq) {
        $ct++;
        $seqinfo->{$ct}->{name} = $seq->display_id;
    }
    
    my $file    = $self->afg_file;
    my $fh      = IO::File->new($file) or die "can't open $file\n";
    my $seekpos = $fh->tell;

    while (my $record = getRecord($fh)){
        my ($rec, $fields, $recs) = parseRecord($record);
        my $nseqs = 0;

        if ($rec eq 'RED') {
            my $id = $fields->{iid};
            $seqinfo->{$id}->{pos} = $seekpos;
        }
        elsif ($rec eq 'CTG') {
            $nContigs++;
            my $ctg_seq = $fields->{seq};
            $ctg_seq =~ s/\n//g;
            $ctg_seq =~ s/-/*/g;
                
            my $ctg_id = $fields->{eid};
            if ($ctg_id =~ /\-/) {
                my ($scaf_num, $ctg_num) = split /\-/, $ctg_id;
                $scaf_num--; #To fit silly pcap scaffold naming
                $ctg_num++;  #To fit silly pcap contig naming
                $ctg_id = 'Contig'.$scaf_num.".$ctg_num";
            }
            else {
                $ctg_id = 'Contig'.$ctg_id;
            }
            
            my $ctg_length = length $ctg_seq;
                
            my $ctg_qual = $fields->{qlt};
            $ctg_qual =~ s/\n//g;
                
            my @ctg_quals;
            for my $i (0..length($ctg_qual)-1) {
                unless (substr($ctg_seq, $i, 1) eq '*') {
                    push @ctg_quals, ord(substr($ctg_qual, $i, 1)) - ord('0');
                }
            }
                                
            my @read_pos;
            my @reads;
            my %left_pos;
            my %right_pos;
                
            for my $r (0..$#$recs) {
                my ($srec, $sfields, $srecs) = parseRecord($recs->[$r]);
                                        
                if ($srec eq 'TLE') {
                    my $ori_read_id = $sfields->{src};
                    unless (defined $ori_read_id) {
                        $self->error_message('TLE record contains no src: field');
                        return;
                    }
                        
                    my $info = $seqinfo->{$ori_read_id};
                    unless ($info) {
                        $self->error_message("Sequence of $ori_read_id (iid) not found, check RED");
                        return;
                    }
                        
                    my $read_id = $info->{name};
                    $read_id .= '-' . $info->{ct} if exists $info->{ct};
                    $seqinfo->{$ori_read_id}->{ct}++;

                    my $sequence = $self->get_seq($fh, $info->{pos}, $ori_read_id);
                    my ($asml, $asmr) = split /,/, $sfields->{clr};

                    ($asml, $asmr) = $asml < $asmr 
                                   ? (0, $asmr - $asml)
                                   : ($asml - $asmr, 0);
                        
                    my ($seql, $seqr) = ($asml, $asmr);

                    my $ori = ($seql > $seqr) ? 'C' : 'U';
                    $asml += $sfields->{off};
		            $asmr += $sfields->{off};

                    if ($asml > $asmr){
                        $sequence = reverseComplement($sequence);
                        my $tmp = $asmr;
			            $asmr = $asml;
			            $asml = $tmp;
			
			            $tmp  = $seqr;
			            $seqr = $seql;
			            $seql = $tmp;
                    }
                        
                    my $off = $sfields->{off} + 1;

                    $asml = 0 if $asml < 0;
		            $left_pos{$read_id}  = $asml + 1;
		            $right_pos{$read_id} = $asmr;
                       
                    my $end5 = $seql + 1;
                    my $end3 = $seqr;
                        
                    push @read_pos, {
                        type      => 'read_position',
                        read_name => $read_id,
                        u_or_c    => $ori,
                        position  => $off,
                    };
                        
                    push @reads, {
                        type              => 'read',
                        name              => $read_id,
                        padded_base_count => length $sequence,
                        info_count        => 0, 
                        tag_count         => 0,
                        sequence          => $sequence,
                        qual_clip_start   => $end5,
                        qual_clip_end     => $end3,
                        align_clip_start  => $end5,
                        align_clip_end    => $end3,
                        description       => {
                            CHROMAT_FILE => $read_id,
                            PHD_FILE     => $read_id.'.phd.1',
                            TIME         => $time,
                        },
                    }
                }         
            }
                        
            my @base_segments = get_base_segments(\%left_pos, \%right_pos, $ctg_length);
                
            my $nBS = scalar @base_segments;
            my $nRd = scalar @read_pos;

            my $contig = {
                type           => 'contig',
                name           => $ctg_id,
                base_count     => $ctg_length,
                read_count     => $nRd,
                base_seg_count => $nBS,
                u_or_c         => 'U',
                consensus      => $ctg_seq,
                base_qualities => \@ctg_quals,
            };
                
            map{$writer->write_object($_)}($contig, @read_pos, @base_segments, @reads);
                $nReads += $nRd;
        }#if 'CTG'
        $seekpos = $fh->tell;
    }#While loop
    
    $writer->write_object({
        type     => 'assembly_tag',
        tag_type => 'comment',
        program  => 'VelvetToAce',
        date     => time2str('%y%m%d:%H%M%S', time),
        data     => "Run by $ENV{USER}\n",
    });
    $out->close;
    
    tie(my @lines, 'Tie::File', $self->out_acefile);
    unshift @lines, sprintf('AS %d %d', $nContigs, $nReads);
    untie(@lines);
    
    return 1;
}


sub get_seq {
    my ($self, $fh, $seekpos, $id) = @_;
    my $pos = $fh->tell;

    $fh->seek($seekpos, 0);
    my $record = getRecord($fh);
    $fh->seek($pos, 0);

    unless (defined $record) {
        $self->error_message("Error for read $id : no record found");
        return;
    }

    my ($rec, $fields, $recs) = parseRecord($record);
    unless ($rec eq 'RED') {
        $self->error_message("Error for read $id : expect RED not $rec at pos $seekpos");
        return;
    }
    unless ($fields->{eid} == $id) {
        $self->error_message("Error for read $id : expect $id not ".$fields->{eid});
        return;
    }

    my $sequence = $fields->{seq};
    $sequence =~ s/\n//g;
    
    return $sequence;
}
    

sub get_base_segments {
    my ($left_pos, $right_pos, $ctg_length) = @_;
    my $prev;
    my @base_segs;
    
    for my $seq (sort{($left_pos->{$a} == $left_pos->{$b}) ?
        ($right_pos->{$b} <=> $right_pos->{$a}):
        ($left_pos->{$a} <=> $left_pos->{$b})
    } (keys %$left_pos)) {
        if (defined $prev) {
            if ($left_pos->{$seq} -1 < $left_pos->{$prev} ||
                $right_pos->{$seq} < $right_pos->{$prev}){
                next;
            }
            push @base_segs, {
                type      => 'base_segment',
                start_pos => $left_pos->{$prev},
                end_pos   => $left_pos->{$seq} - 1,
                read_name => $prev,
            };
        }
        $prev = $seq;
    }

    push @base_segs, {
        type      => 'base_segment',
        start_pos => $left_pos->{$prev},
        end_pos   => $ctg_length,
        read_name => $prev,
    };
    return @base_segs;
}
        
    
1;
#$HeadURL$
#$Id$

