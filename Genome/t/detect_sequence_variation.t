#! /gsc/bin/perl

use warnings;
use strict; 
use YAML::Syck;
use FindBin qw($Bin);
use GSCApp::Test no_plan => 1;
use Data::Dumper;
use Storable;

use Genome;
use Genome::Model::PolyphredPolyscan;
use Genome::Model::CombineVariants;
$ENV{UR_DBI_NO_COMMIT} = 1;
$ENV{UR_USE_DUMMY_AUTOGENERATED_IDS} = 1;
undef @ARGV;

# set autoflush
$| = 1;

use GSCApp;
#App::DB->db_variant('development');
App::DB->db_access_level('rw');
App::DB::TableRow->use_dummy_autogenerated_ids(1);
App->init();
# make this pre-load so it can be examined in the dubugger
GSC::Setup::SequenceAnalysis->class;

my $q = q/
select tp.pse_id from tpp_pse tp
where tp.prior_pse_id in(
select api.pse_id from assembly_project_item@dw api
join assembly_project@dw ap on ap.asp_id = api.asp_id
where ap.assembly_project_name =  ? and rownum =1)/;

#my $asp_name = 'TCGA_Production-0000199_00n-Ensembl-44_36f';
my $asp_name = 'TCGA_Production_Set_1-0000199_00n-Ensembl-44_36f';
#my $asp_name = 'TSP_Project-0002064_061-Ensembl-36_35i';
#my $asp_name = 'TCGA_Production_Set_1-0000244_006-Ensembl-44_36f';
#my $asp_name = 'TCGA_Production_Set_1-0001192_00k-Ensembl-44_36f';

my @detect_seq_var_pses;
my $asp = GSC::AssemblyProject->get(assembly_project_name => $asp_name);
ok($asp, "got assembly project");

my $sth = App::DB->dbh->prepare($q);
$sth->execute($asp_name);

my $ref = $sth->fetchall_arrayref;
ok(($ref and @$ref), "got a update mp assembly pse");
my $control_pse_id = $ref->[0]->[0];
my (@variances, @variances_fs, $snps, $indels, $ps, $ps1,$setup, $ids, $ds, $pps, $pse1, $pse,$tp, $ao, $out_obj, $sample_pos_snp_hash, $sample_pos_indel_hash, $shin_polyphred_out, $shin_obj, $data_directory );
my $shin_storage = '/gscmnt/temp113/finishing/scratch/detect_sequence_variation_test_data';

$setup = GSC::Setup::SequenceAnalysis->get(setup_name => 'Default Detect and Evaluate Sequence Variation');
ok($setup, "got setup");
$ds = GSC::DirectedSetup->get(setup_id => $setup->id);
ok($ds, "got ds");
$ids = GSC::InheritedDirectedSetup->create(pse_id=> $control_pse_id , ds_id => $ds->id);
ok($ids, "created inherited ds");

$ps = GSC::ProcessStep->get(process_to => 'detect sequence variation');
ok($ps, "got ps detect");

($tp) = GSC::ProcessStepTransferPattern->get(ps_id => $ps->id);
ok($tp, "got tp");

#polyphred s 1 10##########################################################
$pps = GSC::ProcessParamSet->get(ps_id => $ps->id, pps_name => 'polyphred s 1 10');
ok($pps, "got process param set");

$pse1 = $ps->init_pse;
ok($pse1, "inited pse");

ok( $pse1->add_param_tp_id($tp->tp_id), "added tp_id");
ok( $pse1->add_param(control_pse_id => $control_pse_id), "added control_pse_id");
ok( $pse1->add_param(asp_id => $asp->asp_id), "added asp_id");
ok( $pse1->add_param(project_dir => '/gsc/var/cache/testsuite/data/GSC-detectsequencevariation/TCGA_Production_Set_1-0000199_00n-Ensembl-44_36f/'), "added /gsc/var/cache/testsuite dir");
ok( $pse1->add_param(pps_id => $pps->id), "added pps_id");
ok( $pse1->confirmable, "confirmable");
ok( $pse1->confirm, "confirmed");
push @detect_seq_var_pses, $pse1;

my $bridge = GSC::Sequence::AnalysisOutputPSE->get(pse_id => $pse1->id);
ok($bridge, "got analysis_output_pse");
 
#Test if output file was successfully stored
#$ao = GSC::Sequence::AnalysisOutput->get(asp_id => $asp->asp_id, sao_type => $pse1->resolve_file_stamp);
#ok($ao, "Got AnalysisOutput obj");
#$out_obj = Load($ao->sao_file);

my $file = $pse1->output_file_name;
ok (-e $file, "$file exists");
$out_obj = $pse1->get_output_file_object($file);
ok (ref $out_obj, "got out obj");

($snps, $indels) =$out_obj->collate_sample_group_mutations;
@variances = (@$snps, @$indels);
ok(@variances, "collatted");

#NOW compare to Shin's files
#$shin_polyphred_out = "$shin_storage/$asp_name/edit_dir/$asp_name.msa.polyphred.out";

#ok(-e $shin_polyphred_out, "test_file $shin_polyphred_out  exists");
#$shin_obj= MG::IO::Polyphred->new(polyphred => $shin_polyphred_out, assembly_project_name => $asp->assembly_project_name);
#ok($shin_obj, "got polyphred shin object");

#($snps, $indels) = $shin_obj->collate_sample_group_mutations;
#@variances_fs = (@$snps, @$indels);
#ok(@variances_fs, "collatted fs");
#
#
#is_deeply(\@variances, \@variances_fs, ".polyscan.out read_group hashes are same");
#
#polyphred s 1 25##########################################################
$pps = GSC::ProcessParamSet->get(ps_id => $ps->id, pps_name => 'polyphred s 1 25');
ok($pps, "got process param set");

$pse1 = $ps->init_pse;
ok($pse1, "inited pse");

ok( $pse1->add_param_tp_id($tp->tp_id), "added tp_id");
ok( $pse1->add_param(control_pse_id => $control_pse_id), "added control_pse_id");
ok( $pse1->add_param(asp_id => $asp->asp_id), "added asp_id");
ok( $pse1->add_param(project_dir => '/gsc/var/cache/testsuite/data/GSC-detectsequencevariation/TCGA_Production_Set_1-0000199_00n-Ensembl-44_36f/'), "added /gsc/var/cache/testsuite dir");
ok( $pse1->add_param(pps_id => $pps->id), "added pps_id");
ok( $pse1->confirmable, "confirmable");
ok( $pse1->confirm, "confirmed");

$bridge = GSC::Sequence::AnalysisOutputPSE->get(pse_id => $pse1->id);
ok($bridge, "got analysis_output_pse");

push @detect_seq_var_pses, $pse1;

#Test if output file was successfully stored
#$ao = GSC::Sequence::AnalysisOutput->get(asp_id => $asp->asp_id, sao_type => $pse1->resolve_file_stamp);
#ok($ao, "Got AnalysisOutput obj");
#$out_obj = Load($ao->sao_file);

$file = $pse1->output_file_name;
ok (-e $file, "$file exists");
$out_obj = $pse1->get_output_file_object($file);
ok (ref $out_obj, "got out obj");

($snps, $indels) =$out_obj->collate_sample_group_mutations;
@variances = (@$snps, @$indels);
ok(@variances, "collatted");

#polyscan s 1 10##########################################################

$pps = GSC::ProcessParamSet->get(ps_id => $ps->id, pps_name => 'polyscan s 1 10');
ok($pps, "got process param set");

$pse = $ps->init_pse;
ok($pse, "inited pse");

ok( $pse->add_param_tp_id($tp->tp_id), "added tp_id");
ok( $pse->add_param(control_pse_id => $control_pse_id), "added control_pse_id");
ok( $pse->add_param(asp_id => $asp->asp_id), "added asp_id");
ok( $pse->add_param(pps_id => $pps->id), "added pps_id");
ok( $pse->confirmable, "confirmable");
ok( $pse->confirm, "confirmed");
push @detect_seq_var_pses, $pse;

$bridge = GSC::Sequence::AnalysisOutputPSE->get(pse_id => $pse->id);
ok($bridge, "got analysis_output_pse");

#Test if output file was successfully stored
#$ao = GSC::Sequence::AnalysisOutput->get(asp_id => $asp->asp_id, sao_type => $pse->resolve_file_stamp);
#ok($ao, "Got AnalysisOutput obj");

#$out_obj = Load($ao->sao_file);
#ok($out_obj, "retrieved recently created polyscan object");

$file = $pse->output_file_name;
ok (-e $file, "$file exists");
$out_obj = $pse->get_output_file_object($file);
ok (ref $out_obj, "got out obj");

($snps, $indels) =$out_obj->collate_sample_group_mutations;
@variances = (@$snps, @$indels);
ok(@variances, "collatted");


#NOW compare to Shin's files

#my $shin_polyscan_out = "$shin_storage/$asp_name/edit_dir/$asp_name.polyscan.out";
#ok(-e $shin_polyscan_out, "polyscan.out $shin_polyscan_out exists");
#my $polyout_obj_shin = MG::IO::Polyscan->new(polyscan => $shin_polyscan_out, assembly_project_name => $asp->assembly_project_name);
#ok($polyout_obj_shin, "got polyscan shin object");
#
#($snps, $indels) =$out_obj->collate_sample_group_mutations;
#@variances_fs = (@$snps, @$indels);
#ok(@variances_fs, "collatted fs");
#
#is_deeply(\@variances, \@variances_fs, ".polyscan.out read_group hashes are same");
#
#polyscan s 1 25##########################################################

$pps = GSC::ProcessParamSet->get(ps_id => $ps->id, pps_name => 'polyscan s 1 25');
ok($pps, "got process param set");

$pse = $ps->init_pse;
ok($pse, "inited pse");

ok( $pse->add_param_tp_id($tp->tp_id), "added tp_id");
ok( $pse->add_param(control_pse_id => $control_pse_id), "added control_pse_id");
ok( $pse->add_param(asp_id => $asp->asp_id), "added asp_id");
ok( $pse->add_param(project_dir => '/gsc/var/cache/testsuite/data/GSC-detectsequencevariation/TCGA_Production_Set_1-0000199_00n-Ensembl-44_36f/'), "added /gsc/var/cache/testsuite dir");
ok( $pse->add_param(pps_id => $pps->id), "added pps_id");
ok( $pse->confirmable, "confirmable");
ok( $pse->confirm, "confirmed");
push @detect_seq_var_pses, $pse;

$bridge = GSC::Sequence::AnalysisOutputPSE->get(pse_id =>  $pse->id);
ok($bridge, "got analysis_output_pse");

#Test if output file was successfully stored
#$ao = GSC::Sequence::AnalysisOutput->get(asp_id => $asp->asp_id, sao_type => $pse->resolve_file_stamp);
#ok($ao, "Got AnalysisOutput obj");
#
#$out_obj = Load($ao->sao_file);
#ok($out_obj, "retrieved recently created polyscan object");

$file = $pse->output_file_name;
ok (-e $file, "$file exists");

$out_obj = $pse->get_output_file_object($file);
ok (ref $out_obj, "got out obj");

($snps, $indels) =$out_obj->collate_sample_group_mutations;
@variances = (@$snps, @$indels);
ok(@variances, "collatted");

###########################################################################
###########################################################################
#Evaluate Sequence Variation
#POLYSCAN EVALUATIVE s 1 10
ok(@detect_seq_var_pses == 4, "got four prior pses"); 

$ps1 = GSC::ProcessStep->get(process_to => 'evaluate sequence variation');
ok($ps1, "got ps evaluate");

my $pse2 = $ps1->init_pse;
ok($pse2, "inited pse");


$pps = GSC::ProcessParamSet->get(ps_id => $ps1->id, pps_name => 'polyscan s 1 10');
ok($pps, "got process param set");

ok( $pse2->add_param_tp_id($tp->tp_id), "added tp_id");
ok( $pse2->add_param(control_pse_id => [map{$_->id}@detect_seq_var_pses]), "added prior_pse_ids");
ok( $pse2->add_param(asp_id => $asp->asp_id), "added asp_id");
ok( $pse2->add_param(project_dir => '/gsc/var/cache/testsuite/data/GSC-detectsequencevariation/TCGA_Production_Set_1-0000199_00n-Ensembl-44_36f/'), "added /gsc/var/cache/testsuite dir");
ok( $pse2->add_param(pps_id => $pps->id), "added pps_id");
ok( $pse2->confirmable, "confirmable");
ok( $pse2->confirm, "confirmed");

$bridge = GSC::Sequence::AnalysisOutputPSE->get(pse_id => $pse2->id);
ok($bridge, "got analysis_output_pse");

# Explicitly create the combine variants model this ONCE to be retreived later

my $subject_name = "detect_sequence_variation_test";
my $combine_variants_data_directory = "/tmp/test_combine_variants_$ENV{USER}/";

my $new_combine_variants_model = Genome::Model::CombineVariants->get_or_create(
    subject_name    =>  $subject_name,  #TODO this has changed
    data_directory  =>  $combine_variants_data_directory,
);
ok($new_combine_variants_model, "Created the new combine variants model explicitly for the new PolyphredPolyscan models");
isa_ok($new_combine_variants_model, "Genome::Model::CombineVariants");

# Check the next step
ok( $pse2->post_confirm, "post_confirm");
$bridge = GSC::Sequence::AnalysisOutputPSE->get(pse_id => $pse2->id);
ok($bridge, "got analysis_output_pse");


my ($tpp_bridge_2) = GSC::TppPSE->get(prior_pse_id => $pse2->id);
ok ($tpp_bridge_2, "got the bridge");
my ($next_pse_2) = GSC::PSE->get($tpp_bridge_2->pse_id);
isa_ok ($next_pse_2, "GSC::PSE::QueueInstrumentDataForGenomeModeling");
$data_directory = "/tmp/test_polyscan_evaluative_1_10_$ENV{USER}/";

ok($next_pse_2->add_param('data_directory', $data_directory), "added data directory param: $data_directory to pse");
ok($next_pse_2->add_param('subject_name', $subject_name), "added test subject name $subject_name to pse");
ok($next_pse_2->confirm, "Called confirm");

ok($next_pse_2->post_confirm, "Called post_confirm");
#GSC::ProcessStep::QueueInstrumentDataForGenomeModeling->execute(pse_id => $next_pse_2->id);


#$ao = GSC::Sequence::AnalysisOutput->get(asp_id => $asp->asp_id, sao_type => $pse2->resolve_file_stamp);
#ok($ao, "Got AnalysisOutput obj");
#$out_obj = Load($ao->sao_file);

$file = $pse2->output_file_name;
ok (-e $file, "$file exists");
$out_obj = $pse2->get_output_file_object($file);
ok (ref $out_obj, "got out obj");

($snps, $indels) =$out_obj->collate_sample_group_mutations;
@variances = (@$snps, @$indels);
ok(@variances, "collatted");


Storable::lock_nstore \@variances, "/gscuser/sabbott/polyphred_read_grop.ser";
#####################################
#POLYSCAN EVALUATIVE s 1 25 
ok(@detect_seq_var_pses == 4, "got four prior pses"); 

$pps = GSC::ProcessParamSet->get(ps_id => $ps1->id, pps_name => 'polyscan s 1 25');
ok($pps, "got process param set");

my $pse3 = $ps1->init_pse;
ok($pse3, "inited pse");
ok( $pse3->add_param_tp_id($tp->tp_id), "added tp_id");
ok( $pse3->add_param(control_pse_id => [map{$_->id}@detect_seq_var_pses]), "added prior_pse_ids");
ok( $pse3->add_param(asp_id => $asp->asp_id), "added asp_id");
ok( $pse3->add_param(project_dir => '/gsc/var/cache/testsuite/data/GSC-detectsequencevariation/TCGA_Production_Set_1-0000199_00n-Ensembl-44_36f/'), "added /gsc/var/cache/testsuite dir");
ok( $pse3->add_param(pps_id => $pps->id), "added pps_id");
ok( $pse3->confirmable, "confirmable");
ok( $pse3->confirm, "confirmed");
$bridge = GSC::Sequence::AnalysisOutputPSE->get(pse_id => $pse3->id);
ok($bridge, "got analysis_output_pse");

# Check the next step
ok( $pse3->post_confirm, "post_confirm");
my ($tpp_bridge_3) = GSC::TppPSE->get(prior_pse_id => $pse3->id);
ok ($tpp_bridge_3, "got the bridge");
my ($next_pse_3) = GSC::PSE->get($tpp_bridge_3->pse_id);
isa_ok ($next_pse_3, "GSC::PSE::QueueInstrumentDataForGenomeModeling");
$data_directory = "/tmp/test_polyscan_evaluative_1_25_$ENV{USER}/";
ok($next_pse_3->add_param('data_directory', $data_directory), "added data directory param:$data_directory to pse");
ok($next_pse_3->add_param('subject_name', $subject_name), "added test subject name $subject_name to pse");
ok($next_pse_3->confirm, "Called confirm");

ok($next_pse_3->post_confirm, "Called post_confirm");
#GSC::ProcessStep::QueueInstrumentDataForGenomeModeling->execute(pse_id => $next_pse_3->id);

#$ao = GSC::Sequence::AnalysisOutput->get(asp_id => $asp->asp_id, sao_type => $pse3->resolve_file_stamp);
#ok($ao, "Got AnalysisOutput obj");
#$out_obj = Load($ao->sao_file);

$file = $pse3->output_file_name;
ok (-e $file, "$file exists");
$out_obj = $pse3->get_output_file_object($file);
ok (ref $out_obj, "got out obj");

($snps, $indels) =$out_obj->collate_sample_group_mutations;
@variances = (@$snps, @$indels);
ok(@variances, "collatted");


################################################################################
#POLYPHRED ForceGenotype s 1 10
$pps = GSC::ProcessParamSet->get(ps_id => $ps1->id, pps_name => 'polyphred s 1 10');
ok($pps, "got process param set");

$pse2 = $ps1->init_pse;
ok($pse2, "inited pse");
ok( $pse2->add_param_tp_id($tp->tp_id), "added tp_id");
ok( $pse2->add_param(control_pse_id => [map{$_->id}@detect_seq_var_pses]), "added prior_pse_ids");
ok( $pse2->add_param(asp_id => $asp->asp_id), "added asp_id");
ok( $pse2->add_param(pps_id => $pps->id), "added pps_id");


ok( $pse2->confirmable, "confirmable");
ok( $pse2->confirm, "confirmed");
$bridge = GSC::Sequence::AnalysisOutputPSE->get(pse_id => $pse2->id);
ok($bridge, "got analysis_output_pse");

# Check the next step
ok( $pse2->post_confirm, "post_confirm");
($tpp_bridge_2) = GSC::TppPSE->get(prior_pse_id => $pse2->id);
ok ($tpp_bridge_2, "got the bridge");
($next_pse_2) = GSC::PSE->get($tpp_bridge_2->pse_id);
isa_ok ($next_pse_2, "GSC::PSE::QueueInstrumentDataForGenomeModeling");
$data_directory = "/tmp/test_polyphred_force_genotype_1_10_$ENV{USER}/";
ok($next_pse_2->add_param('data_directory', $data_directory), "added data directory param:$data_directory to pse");
ok($next_pse_2->add_param('subject_name', $subject_name), "added test subject name $subject_name to pse");
ok($next_pse_2->confirm, "Called confirm");
ok($next_pse_2->post_confirm, "Called post_confirm");
#GSC::ProcessStep::QueueInstrumentDataForGenomeModeling->execute(pse_id => $next_pse_2->id);

#$ao = GSC::Sequence::AnalysisOutput->get(asp_id => $asp->asp_id, sao_type => $pse2->resolve_file_stamp);
#ok($ao, "Got AnalysisOutput obj");
#$out_obj = Load($ao->sao_file);

$file = $pse2->output_file_name;
ok (-e $file, "$file exists");
$out_obj = $pse2->get_output_file_object($file);
ok (ref $out_obj, "got out obj");

($snps, $indels) =$out_obj->collate_sample_group_mutations;
@variances = (@$snps, @$indels);
ok(@variances, "collatted");

################################################################################
#POLYPHRED ForceGenotype s 1 25 
$pps = GSC::ProcessParamSet->get(ps_id => $ps1->id, pps_name => 'polyphred s 1 25');
ok($pps, "got process param set");

$pse2 = $ps1->init_pse;
ok($pse2, "inited pse");
ok( $pse2->add_param_tp_id($tp->tp_id), "added tp_id");
ok( $pse2->add_param(control_pse_id => [map{$_->id}@detect_seq_var_pses]), "added prior_pse_ids");
ok( $pse2->add_param(asp_id => $asp->asp_id), "added asp_id");
ok( $pse2->add_param(project_dir => '/gsc/var/cache/testsuite/data/GSC-detectsequencevariation/TCGA_Production_Set_1-0000199_00n-Ensembl-44_36f/'), "added /gsc/var/cache/testsuite dir");
ok( $pse2->add_param(pps_id => $pps->id), "added pps_id");
ok( $pse2->confirmable, "confirmable");
ok( $pse2->confirm, "confirmed");
$bridge = GSC::Sequence::AnalysisOutputPSE->get(pse_id => $pse2->id);
ok($bridge, "got analysis_output_pse");

# Check the next step
ok( $pse2->post_confirm, "post_confirm");
($tpp_bridge_2) = GSC::TppPSE->get(prior_pse_id => $pse2->id);
ok ($tpp_bridge_2, "got the bridge");
($next_pse_2) = GSC::PSE->get($tpp_bridge_2->pse_id);
isa_ok ($next_pse_2, "GSC::PSE::QueueInstrumentDataForGenomeModeling");
$data_directory = "/tmp/test_polyphred_force_genotype_1_25_$ENV{USER}/";
ok($next_pse_2->add_param('data_directory', $data_directory), "added data directory param:$data_directory to pse");
ok($next_pse_2->add_param('subject_name', $subject_name), "added test subject name $subject_name to pse");
ok($next_pse_2->confirm, "Called confirm");
ok($next_pse_2->post_confirm, "Called post_confirm");
#GSC::ProcessStep::QueueInstrumentDataForGenomeModeling->execute(pse_id =>$next_pse_2->id);


# exec("rm -rf gscmnt/834/info/medseq/polyphred_polyscan//TCGA_Production.polyscan.low");

#$ao = GSC::Sequence::AnalysisOutput->get(asp_id => $asp->asp_id, sao_type => $pse2->resolve_file_stamp);
#ok($ao, "Got AnalysisOutput obj");
#$out_obj = Load($ao->sao_file);

$file = $pse2->output_file_name;
ok (-e $file, "$file exists");
$out_obj = $pse2->get_output_file_object($file);
ok (ref $out_obj, "got out obj");

($snps, $indels) =$out_obj->collate_sample_group_mutations;
@variances = (@$snps, @$indels);
ok(@variances, "collatted");

# Test combine variants stuff

# Check the combine variants model
my $combine_variants_model = Genome::Model::CombineVariants->get( name => "$subject_name.combine_variants" );
ok($combine_variants_model, "Got the combine variants model");
isa_ok($combine_variants_model, "Genome::Model::CombineVariants");

# Check its children and their params
my @combine_variants_children = $combine_variants_model->child_models;
is(@combine_variants_children, 4, "Got (exactly) all 4 combine variants children");

my ($high_count, $low_count, $polyphred_count, $polyscan_count);
for my $combine_variants_child (@combine_variants_children) {
    isa_ok($combine_variants_child, "Genome::Model::PolyphredPolyscan");
    if ($combine_variants_child->sensitivity eq 'high') {
        $high_count++;
    } elsif ($combine_variants_child->sensitivity eq 'low') {
        $low_count++;
    }
    if ($combine_variants_child->technology eq 'polyphred') {
        $polyphred_count++;
    } elsif ($combine_variants_child->technology eq 'polyscan') {
        $polyscan_count++;
    }
}

is ($high_count, 2, "Two of the children are high sensitivity");
is ($low_count, 2, "Two of the children are low sensitivity");
is ($polyphred_count, 2, "Two of the children are polyphred technology");
is ($polyscan_count, 2, "Two of the children are polyscan technology");

# Check combine variants model details...
# these will not work because the build dirs are not set until build
#ok (!-e $combine_variants_model->hq_genotype_file, "hq genotype file doesnt exist yet");
#ok (!-e $combine_variants_model->lq_genotype_file, "lq genotype file doesnt exist yet");

my $hq_polyphred_model = $combine_variants_model->hq_polyphred_model;
ok ($hq_polyphred_model, "got the hq_polyphred_model via combine variants accessor");
isa_ok ($hq_polyphred_model, "Genome::Model::PolyphredPolyscan");

my $lq_polyphred_model = $combine_variants_model->lq_polyphred_model;
ok ($lq_polyphred_model, "got the lq_polyphred_model via combine variants accessor");
isa_ok ($lq_polyphred_model, "Genome::Model::PolyphredPolyscan");

my $hq_polyscan_model = $combine_variants_model->hq_polyscan_model;
ok ($hq_polyscan_model, "got the hq_polyscan_model via combine variants accessor");
isa_ok ($hq_polyscan_model, "Genome::Model::PolyphredPolyscan");

my $lq_polyscan_model = $combine_variants_model->lq_polyscan_model;
ok ($lq_polyscan_model, "got the lq_polyscan_model via combine variants accessor");
isa_ok ($lq_polyscan_model, "Genome::Model::PolyphredPolyscan");

# Test build... should build all 4 child models and the combine variants model
my $cron = Genome::Model::Command::Services::BuildQueuedInstrumentData->create(test=>1);
ok($cron->execute,"Build Cron command returned true");

# Check the files exist
ok (-s $combine_variants_model->hq_genotype_file, "hq genotype file exists");
ok (-s $combine_variants_model->lq_genotype_file, "lq genotype file exists");

# test next_xx_genotype calls
my ($hq_annotated_genotype, $lq_annotated_genotype, $hq_genotype, $lq_genotype);
ok($hq_genotype = $combine_variants_model->next_hq_genotype, "Ran next_hq_genotype");
ok($lq_genotype = $combine_variants_model->next_lq_genotype, "Ran next_lq_genotype");
ok($hq_genotype, "Got the hq_genotype");
ok($lq_genotype, "Got the lq_genotype");

# Attempt to clean up after the test...
my @directories_to_cleanup;
push @directories_to_cleanup, $combine_variants_model->data_directory;
push @directories_to_cleanup, $hq_polyscan_model->data_directory;
push @directories_to_cleanup, $lq_polyscan_model->data_directory;
push @directories_to_cleanup, $hq_polyphred_model->data_directory;
push @directories_to_cleanup, $lq_polyphred_model->data_directory;

for my $data_directory (@directories_to_cleanup) {
    delete_directory_contents($data_directory);
}

# Delete the directory and recursively delete all subdirs and their contents
sub delete_directory_contents {
    my $directory_or_file = shift;
    chomp($directory_or_file);
    
    # if its a directory, recurse
    if (-d $directory_or_file) {
        my @directory_contents = `ls $directory_or_file`;
        for my $new_directory_or_file (@directory_contents) {
            my $full_path = "$directory_or_file/$new_directory_or_file";
            delete_directory_contents($full_path);
        }
        rmdir($directory_or_file);
    }
    else {
        unlink $directory_or_file;
    }
}

