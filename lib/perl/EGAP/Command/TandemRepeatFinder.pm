package EGAP::Command::TandemRepeatFinder;

use strict;
use warnings;

use EGAP;
use Carp 'confess';

class EGAP::Command::TandemRepeatFinder {
    is => 'Command',
    has => [
        fasta_file => {
            is => 'Path',
            is_input => 1,
            doc => 'Fasta file containing supercontigs or contigs of an assembly',
        },
    ],
    has_optional => [
        chunk_size => {
            is => 'Number',
            is_input => 1,
            default => '5000000',
            doc => 'Maximum sequence length allowed per chunk',
        },
        dat_files => {
            is => 'ARRAY',
            is_output => 1,
            doc => 'List of .dat files generated by TRF',
        },
        mask_files => {
            is => 'ARRAY',
            is_output => 1,
            doc => 'List of .mask file generated by TRF',
        },

        # Parameters for executing TRF.
        # TODO Add documentation
        trf_installation_path => {
            is => 'Path',
            is_input => 1,
            default => '/gsc/pkg/bio/trf/',
            doc => 'Path to base installation directory, should have sub-directories for each version',
        },
        version => {
            is => 'Text',
            is_input => 1,
            default => '4.0',
            valid_values => ['3.21', '4.0'],
        },
        matching_weight => {
            is => 'Number',
            is_input => 1,
            default => 2,
        },
        mismatching_penalty => {
            is => 'Number',
            is_input => 1,
            default => 7,
        },
        indel_penalty => {
            is => 'Number',
            is_input => 1,
            default => 7,
        },
        match_probability => {
            is => 'Number',
            is_input => 1,
            default => 80,
        },
        indel_probability => {
            is => 'Number',
            is_input => 1,
            default => 10,
        },
        minimum_reported_alignment_score => {
            is => 'Number',
            is_input => 1,
            default => 50,
        },
        maximum_reported_period_size => {
            is => 'Number',
            is_input => 1,
            default => 500,
        },
        trf_flags => {
            is => 'Text',
            is_input => 1,
            default => '-d -m -h',
            doc => 'Additional flags for trf, valid values are -d, -m, -h, and -f',
        },
    ],
};

sub execute {
    my $self = shift;

    # First, need to break up the fasta file if its too big
    $self->status_message("Splitting up fasta file into chunks no larger than " . $self->chunk_size . " bases.");

    my $split_fasta_command = EGAP::Command::SplitFasta->create(
        fasta_file => $self->fasta_file,
        output_directory => "/gscuser/bdericks/egap_testing",  #FIXME This obviously needs to change
        max_bases_per_file => $self->chunk_size,
    );
    confess "Could not create split fasta file command object!" unless $split_fasta_command;

    my $split_fasta_rv = $split_fasta_command->execute;
    confess "Trouble executing split fasta command!" unless $split_fasta_rv;

    my @fasta_files = @{$split_fasta_command->fasta_files};
    my $num_fastas = scalar @fasta_files;
    my $fasta_directory = $split_fasta_command->output_directory; #FIXME This should change too

    $self->status_message("Created $num_fastas split fastas at $fasta_directory.");

    # Now run trf on each fasta file and track each output file
    my @dat_files;
    my @mask_files;

    my $trf_path = $self->trf_installation_path . '/trf-' . $self->version . '/trf';
    for my $fasta (@fasta_files) {
        my $trf_cmd = join(' ', $trf_path, $fasta, $self->matching_weight, $self->mismatching_penalty, $self->indel_penalty,
            $self->match_probability, $self->indel_probability, $self->minimum_reported_alignment_score, 
            $self->maximum_reported_period_size, $self->trf_flags);
        my $trf_rv = system($trf_cmd);
        confess "Trouble executing TRF command: $trf_cmd" unless defined $trf_rv and $trf_rv == 0;

        my $dat_file = $fasta . '.dat';
        confess "Empty or zero-sized .dat file generated by trf at $dat_file!" unless -e $dat_file and -s $dat_file;
        push @dat_files, $dat_file;

        my $mask_file = $fasta . '.mask';
        confess "Empty or zero-sized .mask file generated by trf at $mask_file!" unless -e $mask_file and -s $mask_file;
        push @mask_files, $mask_file;
    }

    $self->status_message("TRF has been run on each split fasta and a .dat and .mask file was generated for each run!");

    # Store the output files on the command object and return
    $self->dat_files(\@dat_files);
    $self->mask_files(\@mask_files);
    return 1;
}
1;

