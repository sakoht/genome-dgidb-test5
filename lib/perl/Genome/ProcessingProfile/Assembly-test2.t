#!/gsc/bin/perl

use strict;
use warnings;

use above "Genome";
use Test::More;
use File::Path;

use Data::Dumper;

$ENV{UR_DBI_NO_COMMIT} = 1;
$ENV{UR_USE_DUMMY_AUTOGENERATED_IDS} = 1;

my $turn_on_messages = 0;

BEGIN {
    my $archos = `uname -a`;
    if ($archos !~ /64/) {
        plan skip_all => "Must run from 64-bit machine";
    }
    use_ok( 'Genome::InstrumentData::454');
    use_ok( 'Genome::Model::Assembly');
    use_ok( 'Genome::ProcessingProfile::Assembly');
    use_ok( 'Genome::Model::Command::Define' );
    use_ok( 'Genome::ProcessingProfile::Command::Create' );
    use_ok( 'Genome::Model::Event::Build::Assembly' );
    use_ok( 'Genome::Model::Event::Build::Assembly::FilterReadSet' );
    use_ok( 'Genome::Model::Event::Build::Assembly::FilterReadSet::Seqclean' );
    use_ok( 'Genome::Model::Event::Build::Assembly::TrimReadSet' );
    use_ok( 'Genome::Model::Event::Build::Assembly::TrimReadSet::Sfffile' );
    use_ok( 'Genome::Model::Event::Build::Assembly::AddReadSetToProject' );
    use_ok( 'Genome::Model::Event::Build::Assembly::AddReadSetToProject::Newbler' );
    use_ok( 'Genome::Model::Event::Build::Assembly::Assemble' );
    use_ok( 'Genome::Model::Event::Build::Assembly::Assemble::Newbler' );
};

my %pp_0_params = (
		   name => 'test_assembly_processing_profile_1',
		   assembler_name => 'newbler',
		   assembler_params => '-a 0',
		   version_subdirectory => 'offInstrumentApps',
		   read_filter_name => 'seqclean',
		   read_trimmer_name => 'sfffile',
		   sequencing_platform => '454',
		   );

my $pp = Genome::ProcessingProfile::Assembly->create(%pp_0_params);
ok(!$pp, "correctly failed to make a processing profile with no assembler version specified");

my %pp_1_params = (
		   name => 'test_assembly_processing_profile_1',
		   assembler_name => 'newbler',
		   assembler_params => '-a 0',
		   assembler_version => '2.0.00.17-64',
		   read_filter_name => 'seqclean',
		   read_trimmer_name => 'sfffile',
		   sequencing_platform => '454',
		   );

$pp = Genome::ProcessingProfile::Assembly->create(%pp_1_params);
ok(!$pp, "correctly failed to make a processing profile with no version_subdirectory specified");

my %pp_2_params = (
		   name => 'test_assembly_processing_profile_1',
		   assembler_name => 'newbler',
		   assembler_params => '-a 0',
		   assembler_version => '2.0.00.17-64',
		   version_subdirectory => 'offInstrumentApps', 
		   read_filter_name => 'seqclean',
		   read_trimmer_name => 'sfffile',
		   sequencing_platform => '454',
		   );

my %pp_3_params = (
		   name => 'test_assembly_processing_profile_2',
		   assembler_name => 'newbler',
		   assembler_version => '2.0.00.17-64',
		   version_subdirectory => 'offInstrumentApps',
		   assembler_params => '-a 0',
		   sequencing_platform => '454',
		   );
my %pp_4_params = (
		   name => 'test_assembly_processing_profile_3',
		   assembler_name => 'newbler',
		   assembler_params => '-a 0',
		   assembler_version => '10282008',
		   version_subdirectory => 'mapasm454_source', 
		   read_filter_name => 'seqclean',
		   read_trimmer_name => 'sfffile',
		   sequencing_platform => '454',
		   );

my %pp_5_params = (
		   name => 'test_assembly_processing_profile_4',
		   assembler_name => 'newbler',
		   assembler_version => '10282008',
		   version_subdirectory => 'mapasm454_source',
		   assembler_params => '-a 0',
		   sequencing_platform => '454',
		   );



my @pp_params = (\%pp_2_params,\%pp_3_params, \%pp_4_params, \%pp_5_params);

my $skip_assemble = 1;

my $model_base_name = 'test_assembly_model';
my $subject_name = 'TCAM-090304_gDNA_tube1';
my $subject_type = 'sample_name';

for (my $i=0; $i < scalar(@pp_params); $i++) {
    print "Count $i\n\n";

    my $pp_params = $pp_params[$i];
    my $model_name = $model_base_name .'_'. $i;
    my %pp_params = %{$pp_params};
    my $pp = Genome::ProcessingProfile::Assembly->create(%pp_params);

    ok($pp, 'creation worked assembly processing profile');
    isa_ok($pp ,'Genome::ProcessingProfile::Assembly');

    for my $key (keys %pp_params) {
        is($pp->$key,$pp_params{$key},"$key accessor");
    }
    my $data_directory = File::Temp::tempdir(
        'Assembly-XXXXX',
        DIR => '/gsc/var/cache/testsuite/running_testsuites',
        CLEANUP => 1
    );
    my $model_define = Genome::Model::Command::Define::Assembly->create(
                                                                        processing_profile_name => $pp->name,
                                                                        model_name => $model_name,
                                                                        subject_name => $subject_name,
                                                                        subject_type => $subject_type,
                                                                        data_directory => $data_directory,
                                                                    );
 
    isa_ok($model_define,'Genome::Model::Command::Define::Assembly');
    &_trap_messages($model_define);
    ok($model_define->execute,'execute '. $model_define->command_name);

    my @model_status_messages = $model_define->status_messages();
#    my @model_warning_messages = $model_define->warning_messages();
#    my @model_error_messages = $model_define->error_messages();

    ok(scalar(@model_status_messages), $model_define->command_name .' generated status messages');
#    ok(scalar(@model_warning_messages), $model_define->command_name .' generated warning messages');
#    like($model_warning_messages[0],qr(model symlink .* already exists),'warning model symlink already exists');
#    ok(!scalar(@model_error_messages),$model_define->command_name .' generated no error messages');

    my $model = Genome::Model->get(name => $model_name);

    isa_ok($model,'Genome::Model::Assembly');
    is($model->subject_name,$subject_name,'subject_name accessor');
    is($model->subject_type,$subject_type,'subject_type accessor');
    is($model->name,$model_name,'name accessor');
    my $assign_command = Genome::Model::Command::InstrumentData::Assign->create(
                                                                                   model_id => $model->id,
                                                                                   all => 1,
                                                                               );
    isa_ok($assign_command,'Genome::Model::Command::InstrumentData::Assign');
    &_trap_messages($assign_command);
    ok($assign_command->execute(),'execute '. $assign_command->command_name);
    my @status_messages = $assign_command->status_messages();
    ok(scalar(@status_messages), 'instrument-data assign execute printed some status messages');
    ok(scalar(grep { $_ eq 'Attempting to assign all available instrument data'} @status_messages), 'execute mentioned it was adding all reads');
    ok(scalar(grep { $_ =~ /Instrument data .* assigned to model .*/ } @status_messages), '4 instrument data status messages');
    my @warning_messages = $assign_command->warning_messages();
    is(scalar(@warning_messages), 0, 'execute generated no warning messages');
    my @error_messages = $assign_command->error_messages();
    is(scalar(@error_messages), 0, 'execute generated no error messages');

    my $build = Genome::Model::Build->create(
        model_id => $model->id,
    );
    ok($build, 'Created build');
    
    my @workflow_results = $build->_initialize_workflow;
    is(scalar @workflow_results, 1, 'started the build');

    for my $class ($pp->setup_project_job_classes) {
        my @events = $class->get(model_id => $model->id);

        for my $event (@events) {
            &_trap_messages($event);
            # Executing AddReadSetToProject events runs an external program that can
            # print to stdout.  It's failure is properly caught by the caller, so we're
            # not bothering to make sure the message is correct
            my $foo;
            unless ($turn_on_messages) {
                $foo = &_disable_std_out_err();
            }
            my $rv = $event->execute();

            unless ($turn_on_messages) {
                &_enable_std_out_err($foo);
            }
            ok($rv,"execute $class event");
        }
    }

    is($build->assembly_project_xml_file,
       $build->data_directory .'/assembly/454AssemblyProject.xml',
       'expected path to assembly project xml file');
    ok(-s $build->assembly_project_xml_file, '454AssemblyProject.xml file exists with size');

    my $xml_asm_version = Genome::Model::Tools::454::Newbler->get_newbler_version_from_xml_file($build->assembly_project_xml_file) .'-64';

    #skipping this test for mapasm_source runs since xml file for these runs will point to
    #original compelete offInstrumentsApp versions
    unless ($pp->version_subdirectory eq 'mapasm454_source') {
	is($xml_asm_version, $pp_params->{assembler_version}, 'verified correct assembler version');
    }
    my @assemble_events = Genome::Model::Event::Build::Assembly::Assemble->get(model_id => $model->id);
    is(scalar(@assemble_events),1,'one assemble event for project');

    my $assemble = $assemble_events[0];

    isa_ok($assemble,'Genome::Model::Event::Build::Assembly::Assemble');
  SKIP: {
      skip "assemble takes a long time", $skip_assemble;
      ok($assemble->execute,'execute assemble project');
  }
    rmtree($model->data_directory);
}
done_testing();
exit;

sub _trap_messages {
    my $obj = shift;

    $obj->dump_error_messages($turn_on_messages);
    $obj->dump_warning_messages($turn_on_messages);
    $obj->dump_status_messages($turn_on_messages);
    $obj->queue_error_messages(1);
    $obj->queue_warning_messages(1);
    $obj->queue_status_messages(1);
}


# Returns a "token" that can be used later to re-enable them
sub _disable_std_out_err {
    open my $oldout, ">&STDOUT"     or die "Can't dup STDOUT: $!";
    open my $olderr, ">&", \*STDERR or die "Can't dup STDERR: $!";

    open(STDOUT,'>/dev/null');
    open(STDERR,'>/dev/null');

    return { oldout => $oldout, olderr => $olderr };
}

sub _enable_std_out_err {
    my $oldout = $_[0]->{'oldout'};
    my $olderr = $_[0]->{'olderr'};

    open STDOUT, ">&", $oldout or die "Can't dup \$oldout: $!";
    open STDERR, ">&", $olderr or die "Can't dup \$olderr: $!";
}
