package Genome::Utility::TestBase;

use strict;
use warnings;

use base 'Test::Class';

use Carp 'confess';
use Data::Dumper 'Dumper';
use File::Temp 'tempdir';
use Storable qw/ nstore retrieve /;
use Test::More;

#< UR No Commit and Dummy Ids >#
sub _ur_no_commit_and_dummy_ids {
    my $self = shift;

    $ENV{UR_USE_DUMMY_AUTOGENERATED_IDS} = 1;
    ok($ENV{UR_USE_DUMMY_AUTOGENERATED_IDS}, 'Dummy ids') or confess;
    $ENV{UR_DBI_NO_COMMIT} = 1;
    ok($ENV{UR_DBI_NO_COMMIT}, 'DBI no commit') or confess;
    
    return 1;
}

#< CLASS >#
sub create_test_obj { # public method for creating
    my $self = shift;
    eval "use ".$self->test_class;
    return $self->_create_test_obj(@_);
}

sub create_valid_object { # public method for creating
    my $self = shift;
    eval "use ".$self->test_class;
    return $self->_create_valid_object(@_);
}

sub _create_valid_object { 
    return $_[0]->_create_test_obj( $_[0]->params_for_test_class );
}

sub _create_test_obj {
    my $self = shift;
    my $method = $self->new_or_create;
    return $self->test_class->$method(@_);
}

sub new_or_create {
    return ( $_[0]->test_class->can('get_class_object') ) ? 'create' : 'new' ;
}

sub params_for_test_class {
    return;
}

sub required_attrs {
    return;
}

sub required_params_for_class {
    my $self = shift;

    unless ( $self->test_class->can('get_class_object') ) {
        return $self->required_attrs;
    }
    
    my @params;
    for my $property ( $self->test_class->get_class_object->property_metas ) {
        next if defined $property->default_value;
        next if $property->is_optional;
        next if $property->id_by;
        next if $property->reverse_as;
        next if $property->via;
        next if $property->calculate;
        next if $property->property_name =~ /^_/;
        push @params, $property->property_name;
    }
        
    return @params;
}

sub optional_params_for_class {
    return;
}

sub invalid_params_for_test_class {
    return;
}

sub alternate_params_for_test_class {
    return;
}

#< DIR >#
sub base_test_dir {
    return '/gsc/var/cache/testsuite/data';
}

sub test_class_sub_dir {
    return join('-', split('::', $_[0]->test_class));
}

sub dir { 
    return $_[0]->base_test_dir.'/'.$_[0]->test_class_sub_dir;
}

sub tmp_dir {
    my $self = shift;

    unless ( $self->{_tmp_dir} ) {
        $self->{_tmp_dir} = tempdir(CLEANUP => 1);
    }
    
    return $self->{_tmp_dir};
}

#< Mocking >#
sub create_mock_object {
    my ($self, %params) = @_;
    
    my $class = delete $params{class};
    unless ( $class ) {
        confess "No class given to create mock object";
    }

    my $class_meta;
    eval {
        $class_meta = $class->__meta__;
    };
    unless ( $class_meta ) {
        confess "Can't get class meta for $class: $@";
    }

    # Create and set inheritance
    my $obj = Test::MockObject->new();
    $obj->set_always('class', $class);
    $obj->set_isa($class, $class_meta->ancestry_class_names);

    # Get id, add to cache
    my $id = ( exists $params{id} )
    ? delete $params{id}
    : UR::DataSource->next_dummy_autogenerated_id;
    no warnings 'once';
    $UR::Context::all_objects_loaded->{$class}->{$id} = $obj;
    use warnings;

    # UR methods
    $self->mock_methods(
        $obj,
        (qw/
            context_return
            __meta__
            __changes__
            message_object
            error_message error_text
            warning_message
            /),
    );
    $obj->mock('__signal_change__', sub{ 1; });

    # Properties
    my @direct_properties = map { 
        $_->direct_property_metas 
    } ($class_meta, $class_meta->ancestry_class_metas);
    my %properties_seen;
    for my $property ( @direct_properties ) {
        my $property_name = $property->property_name;
        #print Dumper([$class, $property->class_name, $property_name, $property->reverse_as]) if $property->reverse_as;

        # Skip properties already seen
        next if $properties_seen{$property_name};
        $properties_seen{$property_name} = 1;
        
        # Get the value of the property - given or default.
        my $value = exists $params{$property_name}
        ? delete $params{$property_name}
        : $property->default_value;

        # If we got a value, mock directly. This will override the class definition.
        if ( defined $value ) {
            $self->mock_accessors($obj, $property_name);
            $obj->$property_name($value);
            next;
        }
        
        # ID - set always, unless we're given a value.
        if ( $property->is_id ) { # set the id
            $obj->set_always($property_name, $id);
            next;
        }

        # Handle 'is_many' additional methods add and remove
        if ( $property->is_many ) {
            for my $prefix (qw/ add remove /) {
                my $method = $prefix.'_'.$property->singular_name;
                unless ( $class->can($method) ) {
                    #warn "** $class with is_many property ($property_name) can't $method **";
                    next;
                }
                $self->mock_methods($obj, $method);
            }
        }


        # Let UR do it's thing for these.
        if ( grep { $property->$_ } (qw/ is_calculated reverse_as is_delegated /) ) { 
            $self->mock_methods($obj, $property_name);
            next;
        }

        # Not sure how to handle the property, so just mock as an accessor.
        $self->mock_accessors($obj, $property_name);
    }

    return $obj;
}

sub mock_accessors { # Mock an accessor, accounting for many...
    my ($self, $obj, @accessors) = @_;

    confess "To mock accessors, requires params are: object and accessor names.  Got ".scalar(@_)." params." unless @_ >= 3;

    for my $accessor ( @accessors ) {
        my $accessor_name = '_'.$accessor; 
        $obj->mock(
            $accessor, 
            sub {
                my $object = shift;
                $object->{$accessor_name} = \@_ if @_;
                return unless $object->{$accessor_name};
                return ( scalar(@{$object->{$accessor_name}}) eq 1 )
                ? $object->{$accessor_name}->[0] 
                : @{$object->{$accessor_name}};
            }
        );
    }

    return 1;
}

sub mock_methods {
    my ($self, $obj, @methods) = @_;

    confess "To mock methods, needed params are: object and methods.  Only got ".scalar(@_)." params." unless @_ >= 3;
    
    my $class = $obj->class;
    confess "Can't get class from object to mock methods: ".Dumper($obj) unless $class;
    
    no strict 'refs';
    for my $method ( @methods ) {
        my $sub = $class->can($method);
        confess "Can't find method ($method) in class ($class)" unless $sub;
        my $class_method = $class.'::'.$method;
        $obj->mock(
            $method,
            sub{ $sub->(@_); },
        );
    }

    return 1;
}

#< Helper Methods >#
sub store_file  {
    my ($self, $ref, $file) = @_;

    die "Invalid ref to store\n" unless $ref and ref $ref;

    Genome::Sys->validate_file_for_writing($file)
        or die;
    
    return nstore($ref, $file);
}

sub retrieve_file {
    my ($self, $file) = @_;

    Genome::Sys->validate_file_for_reading($file)
        or die;
    
    return retrieve($file);
}

#< Base Tests >#
sub test001_use : Test(1) {
    my $self = shift;

    use_ok( $self->test_class )
        or die;

    return 1;
}

sub test002_create : Test(2) {
    my $self = shift;

    $self->{_object} = $self->_create_valid_object;
    ok($self->{_object}, "Created ".$self->test_class);
    isa_ok($self->{_object}, $self->test_class);

    return 1;
}

sub test003_required_params : Tests {
    my $self = shift;

    my %params = $self->params_for_test_class
        or return 1;
    for my $attr ( $self->required_params_for_class ) {
        my $val = delete $params{$attr};
        my $obj;
        eval {
            $obj = $self->_create_test_obj(%params);
        };
        diag("$@\n");
        ok(!$obj, "Failed as expected - create w/o required attr: $attr");
        $params{$attr} = $val;
    }

    return 1;
}

sub test004_optional_params : Tests {
    my $self = shift;

    my %params = $self->params_for_test_class
        or return 1;
    for my $attr ( $self->optional_params_for_class ) {
        my $val = delete $params{$attr};
        my $obj;
        eval {
            $obj = $self->_create_test_obj(%params);
        };
        ok($obj, "Create w/o optional attr: $attr") or die;
        $obj->delete if $obj->can('delete');
        $params{$attr} = $val;
    }

    return 1;
}

sub test005_invalid_params : Tests {
    my $self = shift;

    my %invalid_params = $self->invalid_params_for_test_class
        or return 1;
    my %params = $self->params_for_test_class;
    for my $attr ( keys %invalid_params ) {
        my $val = delete $params{$attr};
        $params{$attr} = $invalid_params{$attr};
        my $obj;
        eval {
            $obj = $self->_create_test_obj(%params);
        };
        diag("$@\n");
        ok(!$obj, "Failed as expected - create w/ invalid attr $attr => ".$invalid_params{$attr});
        $params{$attr} = $val;
    }

    return 1;
}

1;

=pod

=head1 Name

ModuleTemplate

=head1 Synopsis

=head1 Usage

=head1 Methods

=head2 

=over

=item I<Synopsis>

=item I<Arguments>

=item I<Returns>

=back

=head1 See Also

=head1 Disclaimer

Copyright (C) 2005 - 2008 Washington University Genome Sequencing Center

This module is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY or the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.

=head1 Author(s)

B<Eddie Belter> I<ebelter@watson.wustl.edu>

=cut

#$HeadURL$
#$Id$

