package Genome::Site::WUGC::Disk::Allocation;

# Adaptor for GSC::DiskAllocation

# Do NOT use this module from anything in the GSC schema,
# though the converse will work just fine.

# This module will handle all PSE calls based on modifications

use strict;
use warnings;

use Genome;
use Genome::Utility::AsyncFileSystem qw/on_each_line/;
use Sys::Hostname qw/hostname/;

class Genome::Site::WUGC::Disk::Allocation {
    table_name => 'GSC.disk_allocation disk_allocation',
    id_by => [
        allocator_id => {
            is => 'Number',
            doc => 'The id for the allocator event',
        },
    ],
    has => [
        disk_group_name => {
            is => 'Text',
            doc => 'The name of the disk group',
        },
        mount_path => {
            is => 'Text',
            doc => 'The mount path of the disk volume',
        },
        allocation_path => {
            is => 'Text',
            doc => 'The sub-dir of the disk volume for which space is allocated',
        },
        kilobytes_requested => {
            is => 'Number',
            doc => 'The disk space allocated in kilobytes',
        },
        kilobytes_used => {
            is => 'Number',
            doc => 'The actual disk space used by owner',
        },
        owner_class_name => {
            is => 'Text',
            doc => 'The class name for the owner of this allocation',
        },
        owner_id => {
            is => 'Text',
            doc => 'The id for the owner of this allocation',
        },
        owner => { id_by => 'owner_id', is => 'UR::Object', id_class_by => 'owner_class_name' },
        group_subdirectory => {
            is => 'Text',
            doc => 'The group specific subdirectory where space is allocated',
        },
        absolute_path => {
            calculate_from => ['mount_path','group_subdirectory','allocation_path'],
            calculate => q|
                return $mount_path .'/'. $group_subdirectory .'/'. $allocation_path;
            |,
        },
    ],
    has_optional => [
        allocator => {
            calculate_from => 'allocator_id',
            calculate => q|
                return GSC::PSE::AllocateDiskSpace->get($allocator_id);
            |,
            doc => 'The allocate disk space PSE',
        },
        volume => { 
                        is => 'Genome::Disk::Volume',
            calculate_from => 'mount_path',
            calculate => q{
                return Genome::Disk::Volume->get(mount_path => $mount_path);
            },
        }
    ],
    data_source => 'Genome::DataSource::GMSchema',
};

sub build {

    my ($self) = @_;
    return if $self->owner_class_name !~ /^Genome::Model::Build/;

    my $build_id = $self->owner_id();
    my $build = Genome::Model::Build->get($build_id);
    return $build;
}

our $test_allocation = 0;
sub test_allocation {
    my $class = shift;
    if (@_) {
        $test_allocation = shift;
    }
    return $test_allocation;
}

sub allocate {
    my $class = shift;
    my %params = (@_);

    my @required_params = qw (allocation_path disk_group_name kilobytes_requested owner_class_name owner_id);
    for (@required_params) {
        unless (defined($params{$_})) {
            die($_ .' param is required to allocate in '. $class .' and got params '. "\n". Data::Dumper::Dumper(%params) ."\n");
        }
    }
    my $allocation;
    if ($ENV{UR_DBI_NO_COMMIT}) {
        if ($class->test_allocation) {
            my $allocate_cmd = Genome::Site::WUGC::Disk::Allocation::Command::Allocate->execute(%params);

            unless($allocate_cmd) {
                die('Failed to allocate disk space with params '. %params);
            }
            $allocation = Genome::Site::WUGC::Disk::Allocation->load(
                                                           allocation_path => $params{allocation_path},
                                                           disk_group_name => $params{disk_group_name},
                                                           owner_class_name => $params{owner_class_name},
                                                           owner_id => $params{owner_id},
                                                       );
        } else {
            local $UR::DataSource::use_dummy_autogenerated_ids = 1;

            my $group = Genome::Disk::Group->get(disk_group_name => $params{disk_group_name});
            unless ($group) {
                die 'cannot find disk group: ' . $params{disk_group_name};
            }

            my $tmpdir = Genome::Utility::FileSystem->base_temp_directory();

            my $id = $class->__meta__->autogenerate_new_object_id;
            $allocation = $class->__define__(
                id => $id,
                allocator_id => $id,
                allocation_path => $params{allocation_path},
                disk_group_name => $params{disk_group_name},
                owner_class_name => $params{owner_class_name},
                owner_id => $params{owner_id},
                kilobytes_requested => $params{kilobytes_requested},
                kilobytes_used => 0,
                group_subdirectory => $group->subdirectory,
                mount_path => $tmpdir,
                absolute_path => $tmpdir . '/' . $group->subdirectory . '/' . $params{allocation_path} 
            );
            my $path = $allocation->absolute_path;
            unless (-e $path) {
                Genome::Utility::FileSystem->create_directory($path);
                unless (-e $path) {
                    die $class->error_message("Failed to create directory $path! $!");
                }
            }
        }
    } else {
        my $allocate_cmd = sprintf('genome disk allocation allocate --allocation-path=%s --disk-group-name=%s --kilobytes-requested=%s --owner-class-name=%s --owner-id=%s',
                                $params{allocation_path},
                                $params{disk_group_name},
                                $params{kilobytes_requested},
                                $params{owner_class_name},
                                $params{owner_id},
                            );
        if ($params{mount_path}) {
            $allocate_cmd .= ' --mount-path='. $params{mount_path};
        }
        unless($class->monitor_allocate_command($allocate_cmd)) {
            die('Failed to allocate disk space with command '. $allocate_cmd);
        }
        $allocation = Genome::Site::WUGC::Disk::Allocation->load(
                                                       allocation_path => $params{allocation_path},
                                                       disk_group_name => $params{disk_group_name},
                                                       owner_class_name => $params{owner_class_name},
                                                       owner_id => $params{owner_id},
                                                   );
    }

    unless ($allocation) {
        die('Failed to get '. $params{disk_group_name} .' disk allocation for '. $params{owner_class_name} .'('. $params{owner_id}
            .') with allocation path '. $params{allocation_path});
    }
    return $allocation;
}

sub reallocate {
    my $self = shift;
    my %params = @_;
    if ($ENV{UR_DBI_NO_COMMIT}) {
        if ($self->test_allocation) {
            my $reallocate_cmd = Genome::Site::WUGC::Disk::Allocation::Command::Reallocate->execute(
                                                                                        allocator_id => $self->allocator_id,
                                                                                        %params
                                                                                    );
            unless ($reallocate_cmd) {
                $self->error_message('Failed to reallocate disk space with command '. $reallocate_cmd);
                return;
            }
        }
        ## no-op here.  may need to fix this if people actually start checking the kilobytes_requested
    } else {
        my $reallocate_cmd = sprintf('genome disk allocation reallocate --allocator-id=%s',$self->allocator_id);
        if ($params{kilobytes_requested}) {
            $reallocate_cmd .= ' --kilobytes-requested='. $params{kilobytes_requested};
        }
        unless($self->monitor_allocate_command($reallocate_cmd)) {
            $self->error_message('Failed to reallocate disk space with command '. $reallocate_cmd);
            return;
        }
    }
    return 1;
}

sub deallocate {
    my $self = shift;
    if ($ENV{UR_DBI_NO_COMMIT}) {
        if ($self->test_allocation) {
            my $deallocate_cmd = Genome::Site::WUGC::Disk::Allocation::Command::Deallocate->execute(allocator_id => $self->allocator_id);
            unless ($deallocate_cmd) {
                $self->error_message('Failed to deallocate disk space with command '. $deallocate_cmd);
                return;
            }
        }
        ## no-op here.  may need to fix this if people actually start checking for the allocator
    } else {
        my $deallocate_cmd = sprintf('genome disk allocation deallocate --allocator-id=%s',$self->allocator_id);
        unless ($self->monitor_allocate_command($deallocate_cmd)) {
            $self->error_message('Failed to deallocate disk space with command '. $deallocate_cmd);
            return;
        }
    }
    return 1;
}

sub get_actual_disk_usage {
    my $self = shift;
    
    my $allocator = $self->allocator;

    my $kb = $allocator->get_actual_disk_usage;

    return $kb;
}

sub pse_not_complete {
    my $self = shift;
    my $pse = shift;
    my @not_completed = grep { $_ eq $pse->pse_status } ('scheduled', 'wait', 'confirm', 'confirming');
    unless (@not_completed) {
        return;
    }
    return 1;
}

## warning times in seconds
our $after_start = 3600;
our $after_lock_acquired = 600;
sub monitor_allocate_command {
    my $self = shift;
    my $cmd = shift;

    my $pid;
    my $lock_acquire_time;         # will be set once we see the lock acquired
    my $ow;                        # overall watcher;
    my $w;                         # after lock acquired watcher;

    my $trace_fh = File::Temp->new(
        'TEMPLATE' => hostname . '-' . $$ . '_XXXX',
        'DIR'      => '/gsc/var/log/genome/allocation_debugging',
        'SUFFIX'   => '.log',
        'UNLINK'   => '1'
    );
    $trace_fh->autoflush(1);
    chmod 0644, $trace_fh;
 
    $ow = AnyEvent->timer(
        after => $after_start,
        cb => sub {
           $self->send_message_about_command($cmd,$pid,$after_start,0);
           undef $ow;
           undef $w;
    });
    
    $self->status_message('Allocation process started at ' . UR::Time->now);
    my $cv = Genome::Utility::AsyncFileSystem->shellcmd(
        cmd => $cmd,
        '>' => sub {
            if (defined $_[0]) {
                print $trace_fh $_[0];
                print STDOUT $_[0];
            }
        },
        '3>' => sub {
            if (defined $_[0]) {
                print $trace_fh $_[0];
            }
        },
        '2>' => on_each_line {
            if (defined $_[0]) {
                print $trace_fh $_[0];
                if ($_[0] =~ /^genome allocate: STATUS: Lock acquired/) {
                    $self->status_message('Allocation lock acquired at ' . UR::Time->now);
                    $w = AnyEvent->timer(
                        after => $after_lock_acquired,
                        cb => sub {
                           $self->send_message_about_command($cmd,$pid,$after_lock_acquired,1);
                           undef $ow;
                           undef $w;
                    });
                } elsif ($_[0] =~ /Committed and released lock/) {
                    $self->status_message('Allocation lock released at ' . UR::Time->now);
                    undef $w;
                    undef $ow;
                } else {
                    print STDERR $_[0];
                }
            }
        },
        '$$' => \$pid
    );
    $cv->cb(sub {
        undef $ow;
        undef $w;
        $self->status_message('Allocation command ended at ' . UR::Time->now);
        close $trace_fh;
        undef $trace_fh;  #explicit destroy

    });
    
    return $cv->recv;
}

sub send_message_about_command {
    my $self = shift;
    my $cmd = shift;
    my $pid = shift;
    my $after = shift;
    my $was_lock_acquired = shift;

    my $lock_msg = $was_lock_acquired 
        ? 'Lock Held' 
        : '';

    my $message = <<MESSAGE;
To whom it may concern,

This command:

$cmd

Has not exited after $after seconds. $lock_msg

Host: %s
My Pid: %s 
Allocation Pid: %s
LSF Job: %s
User: %s

This is the only warning you will receive about this process.  Action
may be required.
MESSAGE

    my $from = '"' . __PACKAGE__ . sprintf('" <%s@genome.wustl.edu>', Genome::Sys->username);

    my $to = join(', ', map { Genome::Config->user_email($_) } Genome::Config->admin_notice_users());
    my $subject = 'Allocation problem on ' . hostname . ' pid ' . $pid . '. ' . $lock_msg;
    my $data = sprintf($message,
        hostname,$$,$pid,($ENV{LSB_JOBID} || ''),scalar(getpwuid($<)));

    my $msg = MIME::Lite->new(
        From => $from,
        To => $to,
        Subject => $subject,
        Data => $data
    );
    $msg->send();

}


1;




