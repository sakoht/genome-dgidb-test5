#----------------------------------
# $Author: bshore $
# $Date: 2008-07-01 09:11:56 -0500 (Tue, 01 Jul 2008) $
# $Revision: 36100 $
# $URL: svn+ssh://svn/srv/svn/gscpan/perl_modules/trunk/MG/MutationDiagram/Backbone.pm $
#----------------------------------
package MG::MutationDiagram::Backbone;

#------------------------------------------------
our $VERSION = '1.0';

#------------------------------------------------
use strict;
use warnings;
use SVG;
use MG::MutationDiagram::View;

# If you know about and want to use inheritance:
#use Base::Class;
our @ISA = qw( MG::MutationDiagram::View);

sub new {
    my ( $class, %arg ) = @_;

    #set up viewport
    $arg{viewport} = {
        x      => 0,
        y      => 0,
        height => $arg{height},            #default to available space
        width  => $arg{protein_length},    #expected to be in amino acids
    };

    my $self = MG::MutationDiagram::View->new(%arg);
    $self->{_protein_length}   = $arg{protein_length};
    $self->{_backbone}{height} = $arg{backbone_height};
    $self->{_gene}             = $arg{gene};

    #we want to center the backbone within the available space
    $self->{_backbone}{x} = 0;
    $self->{_backbone}{y} =
      ( $self->{_viewport}{height} - $self->{_backbone}{height} ) / 2;

    bless( $self, ref($class) || $class );
    return $self;
}

#----------------------------------
sub dimensions {
    my ( $self, ) = @_;
    return $self->{_backbone};
}

#-------------------------------------------------
sub draw {
    my ( $self, ) = @_;
    my $svg = $self->{_svg};
    $svg->rectangle(
        id     => $self->{id},
        x      => $self->{_backbone}{x},
        y      => $self->{_backbone}{y},
        width  => $self->{_protein_length},
        height => $self->{_backbone}{height},
        style  => $self->{_style}

    );

    my $coord_increment = int( $self->{_protein_length} / 5 / 100 ) * 100;
    $coord_increment ||= 50;
    my $coord_i;
    for (
        $coord_i = 0 ;
        $coord_i < $self->{_protein_length} ;
        $coord_i += $coord_increment
      )
    {
        $svg->line(
            x1    => $coord_i,
            y1    => $self->{_backbone}{y} + $self->{_backbone}{height},
            x2    => $coord_i,
            y2    => $self->{_backbone}{y} + $self->{_backbone}{height} + 5,
            style => {
                fill   => 'none',
                stroke => 'black'
            }
        );

        #			if ($coord_i % (2 * $coord_increment)) {
        my $coord_label = $coord_i;
        $svg->text(
            id    => 'coordinate_' . $coord_label,
            x     => $coord_i,
            y     => $self->{_backbone}{y} + $self->{_backbone}{height} + 20,
            style => {
                'text-align'  => 'center',
                'text-anchor' => 'middle'
            }
        )->cdata($coord_label);

        #			}
    }
    if ( $coord_i - int( $coord_increment / 2 ) < $self->{_protein_length} ) {
        $coord_i = $self->{_protein_length};
        $svg->line(
            x1    => $coord_i,
            y1    => $self->{_backbone}{y} + $self->{_backbone}{height},
            x2    => $coord_i,
            y2    => $self->{_backbone}{y} + $self->{_backbone}{height} + 5,
            style => {
                fill   => 'none',
                stroke => 'black'
            }
        );
        my $coord_label = $coord_i;
        $svg->text(
            id    => 'coordinate_' . $coord_label,
            x     => $coord_i,
            y     => $self->{_backbone}{y} + $self->{_backbone}{height} + 20,
            style => {
                'text-align'  => 'center',
                'text-anchor' => 'middle'
            }
        )->cdata($coord_label);
    }

    my $coord_scale = $svg->text(
        id    => 'coordinate_scale',
        x     => $self->{_protein_length} / 2,
        y     => $self->{_backbone}{y} + $self->{_backbone}{height} + 30,
        style => {
            'text-align'  => 'center',
            'text-anchor' => 'middle',
        }
    )->cdata('Scale (AA)');

    my $gene_name = $svg->text(
        id    => 'gene_name',
        x     => $self->{_protein_length} / 2,
        y     => $self->{_backbone}{y} + $self->{_backbone}{height} + 60,
        style => {
            'text-align'  => 'center',
            'text-anchor' => 'middle',
            'font-size'   => 24,
            'font-style'  => 'italic',
            'font'        => 'Myriad-Roman',
          }

    )->cdata( $self->{_gene} );
}

#-------------------------------------------------
#BEGIN DOCUMENTATION
#-------------------------------------------------

=pod

=head1 NAME

 ValidateCosmic - module that validates information loaded by the MG::IO::Parse::Cosmic module against the MPSampleData database.

=head1 SYNOPSIS

 #!/gsc/bin/perl
 
 use strict;
 use warnings;
 use ValidateCosmic;
 
 my($validator) = ValidateCosmic->new(-db => 'sd_test');
 
 or
 
 my($validator) = ValidateCosmic->new();

 $validator->Check(\%cosmic_hash);
 exit 1;

=head1 Constructors

=head3 new
 
 Title   : new
 Usage   : ValidateCosmic->new(%args); 
 Function: Creates a validator object
 Returns : A new object
 Args    : Passed a hash of arguments
           -db => name of database to use  

=head1 Interface Methods
 

=head3 Check
 
 Title   : Check
 Usage   : $validate_obj->Check(\%cosmic_hash); 
 Function: Validates the COSMIC data versus the database in MPSampleData
 Returns : False if any of the COSMIC data does not validate against the database
 Args    : Expects a reference to the hash containing the COSMIC data
 Notes   : Check modifies the hash as follows:

=over 4

=item * 

If a gene is found to have multiple chromosomes associated with it in the database. The key 'validation_error'
will be added to the %cosmic{<GENE>} hash. The presence of this value should be tested post-validation.

=item *

If a sample fails at any point in the validation process, the key 'validation_error'
will be added to the %cosmic{<GENE>}{<SAMPLE_ID>} hash. The presence of this value should be tested post-validation.
Inside this hash will be keys defining the where various checks failed.
Keys of this hash include: 'chromosome', 'genomic_coordinates'.
The value of these keys will contain a string indicating why that particular check failed.

=item *

For valid chromosomes, the 'chrom_id' key will be added to the Sample_ID hash with the chromosome associated with that mutation

=back

=head1 EXPORT

None by default

=head1 SEE ALSO

MG::IO::Parse::Cosmic.

=head1 FILES

Files used by this module.

=head1 BUGS

Unfinished

=head1 AUTHOR

David Larson, E<lt>dlarson@watson.wustl.eduE<gt>

=head1 COPYRIGHT AND LICENSE

Copyright (C) 2008 by David Larson

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8 or,
at your option, any later version of Perl 5 you may have available.


=cut

1;

