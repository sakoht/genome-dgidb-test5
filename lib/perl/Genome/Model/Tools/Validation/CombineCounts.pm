package Genome::Model::Tools::Validation::CombineCounts;

use strict;
use warnings;

use Genome;
use Genome::Info::IUB;
use IO::File;
use POSIX;

class Genome::Model::Tools::Validation::CombineCounts {
    is => 'Command',
    has => [
    count_files => {
        type => 'String',
        is_optional => 0,
        doc => 'Files of counts generated by gmt validation count-contigs. Comma separated values',
        default => '',
    },
    file_labels => {
        type => 'String',
        is_optional => 1,
        doc => 'Labels to assign the files passed in --count-files. Should be comma separated ie tumor,normal,relapse',
    },

    ]
};

sub execute {
    my $self=shift;
    $DB::single = 1;
    my @files = split /\s*,\s*/, $self->count_files;
    my @orig_labels = split /\s*,\s*/, $self->file_labels if $self->file_labels;
    my @labels = @orig_labels;  #set this up so we can pop off labels during file parsing

    my %counts; #counts of the contigs and their variants

    #info on the count headers/fields
    my @contig_specific_fields = qw( contig_id contigs_overlapping);
    my @bam_specific_fields = qw( ref_clipped_reads_excluded ref_paralog_reads_excluded total_reads_crossing_ref_pos total_q1_reads_crossing_ref_pos total_q1_reads_spanning_ref_pos contig_clipped_reads_excluded contig_paralog_reads_excluded total_reads_crossing_contig_pos total_q1_reads_crossing_contig_pos total_q1_reads_spanning_contig_pos );
    my @sample_calculated_fields = qw( coverage frequency excluded_freq clip_freq paralog_freq);
    
    for my $file (@files) {
        my $fh = IO::File->new($file, "r");
        unless($fh) {
            $self->error_message("Couldn't open $file: $!"); 
            return;
        }

        my $label;
        if(@labels) {
            $label = shift @labels; #grab the label for this file
        }
        else {
            $label = $file;
        }


        #parse in the counts
        while(my $line = $fh->getline) {
            next if $line =~ /contig_id/;   #skip the header
            chomp $line;

            my @fields = split /\t/, $line;

            my ($contig_id, $overlap) = @fields;

            my $count_entry;
            if(exists($counts{$contig_id})) {
                unless($counts{$contig_id}{contigs_overlapping} == $overlap) {
                    #mismatching overlap notation, probably not the same set of contigs
                    $self->error_message("Mismatching overlap number between contigs, did you use the same contigs for your two files?");
                    return;
                }
                $count_entry = $counts{$contig_id};
            }
            else {
                $counts{$contig_id}{contigs_overlapping} = $overlap;
                $count_entry = $counts{$contig_id};
            }

            #check that we don't have a duplicate label
            if(exists($count_entry->{$label})) {
                $self->error_message("Duplicate data or duplicate label for $contig_id with label $label");
                return;
            }

            @{$count_entry->{$label}}{@bam_specific_fields} = @fields[2..$#fields]; #store the info
        }
    }

    #now we're all done, lets spit this stuff out. 

    #spit out a header, cause that's a good idea

    my @labeled_calculated_header;
    print join("\t", @contig_specific_fields); 
    foreach my $label (@orig_labels) {
        my @labeled_fields =  map { "${label}_$_" } @bam_specific_fields;
        print "\t", join("\t", @labeled_fields);

        push @labeled_calculated_header, map { "${label}_$_" } @sample_calculated_fields;
    }

    print "\t",join("\t", @labeled_calculated_header);
    print "\t", qw( contig_exclusion_freq );
    print "\n";

    #now print the data
    foreach my $contig_id (sort keys %counts) {
        print join("\t",$contig_id, $counts{$contig_id}{contigs_overlapping});
        my @calculated_fields;
        my $total_contig_reads = 0;
        my $total_excluded_contig_reads = 0;
        foreach my $label (@orig_labels) {
            my @fields = @{$counts{$contig_id}{$label}}{@bam_specific_fields};
            print "\t",join("\t",@fields);
            
            #calculate the per sample metrics
            my $coverage = $counts{$contig_id}{$label}->{total_q1_reads_spanning_ref_pos} + $counts{$contig_id}{$label}->{total_q1_reads_spanning_contig_pos};
            my $frequency = $coverage ? $counts{$contig_id}{$label}->{total_q1_reads_spanning_contig_pos} / ($counts{$contig_id}{$label}->{total_q1_reads_spanning_contig_pos} + $counts{$contig_id}{$label}->{total_q1_reads_spanning_ref_pos}) : '-';
            my $total_reads = ($counts{$contig_id}{$label}->{contig_clipped_reads_excluded} + $counts{$contig_id}{$label}->{contig_paralog_reads_excluded} + $counts{$contig_id}{$label}->{total_reads_crossing_contig_pos});
            my $excluded_contig_freq = $total_reads ? ($counts{$contig_id}{$label}->{contig_clipped_reads_excluded} + $counts{$contig_id}{$label}->{contig_paralog_reads_excluded}) / $total_reads : '-';
            my $clip_freq = $total_reads ? $counts{$contig_id}{$label}->{contig_clipped_reads_excluded} / $total_reads : '-';
            my $paralog_freq = $total_reads ? $counts{$contig_id}{$label}->{contig_paralog_reads_excluded} / $total_reads : '-';
            push @calculated_fields, join("\t", join("\t",$coverage, $frequency, $excluded_contig_freq, $clip_freq, $paralog_freq));

            $total_contig_reads += $total_reads;
            $total_excluded_contig_reads += $counts{$contig_id}{$label}->{contig_clipped_reads_excluded} + $counts{$contig_id}{$label}->{contig_paralog_reads_excluded};

        }
        print "\t",join("\t", @calculated_fields);
        print "\t", $total_contig_reads ? $total_excluded_contig_reads / $total_contig_reads : '-';
        print "\n";
    }
    return 1;
}


1;

sub help_brief {
    "Scans a file of contigs, parses information about where they need to be counted and then spits out info."
}

sub help_detail {
    <<'HELP';
HELP
}
