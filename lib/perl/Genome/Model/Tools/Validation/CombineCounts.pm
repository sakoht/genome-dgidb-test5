package Genome::Model::Tools::Validation::CombineCounts;

use strict;
use warnings;

use Genome;
use Genome::Info::IUB;
use IO::File;
use POSIX;

class Genome::Model::Tools::Validation::CombineCounts {
    is => 'Command',
    has => [
    count_files => {
        type => 'String',
        is_optional => 0,
        doc => 'Files of counts generated by gmt validation count-contigs. Comma separated values',
        default => '',
    },
    file_labels => {
        type => 'String',
        is_optional => 1,
        doc => 'Labels to assign the files passed in --count-files. Should be comma separated ie tumor,normal,relapse',
    },

    ]
};

sub execute {
    my $self=shift;
    $DB::single = 1;
    my @files = split /\s*,\s*/, $self->count_files;
    my @orig_labels = split /\s*,\s*/, $self->file_labels if $self->file_labels;
    my @labels = @orig_labels;  #set this up so we can pop off labels during file parsing

    my %counts; #counts of the contigs and their variants

    #info on the count headers/fields
    my @contig_specific_fields = qw( contig_id contigs_overlapping);
    my @bam_specific_fields = qw( total_reads_crossing_ref_pos total_q1_reads_crossing_ref_pos total_q1_reads_spanning_ref_pos total_reads_crossing_contig_pos total_q1_reads_crossing_contig_pos total_q1_reads_spanning_contig_pos );
    
    for my $file (@files) {
        my $fh = IO::File->new($file, "r");
        unless($fh) {
            $self->error_message("Couldn't open $file: $!"); 
            return;
        }

        my $label;
        if(@labels) {
            $label = shift @labels; #grab the label for this file
        }
        else {
            $label = $file;
        }


        #parse in the counts
        while(my $line = $fh->getline) {
            next if $line =~ /contig_id/;   #skip the header
            chomp $line;

            my @fields = split /\t/, $line;

            my ($contig_id, $overlap) = @fields;

            my $count_entry;
            if(exists($counts{$contig_id})) {
                unless($counts{$contig_id}{contigs_overlapping} == $overlap) {
                    #mismatching overlap notation, probably not the same set of contigs
                    $self->error_message("Mismatching overlap number between contigs, did you use the same contigs for your two files?");
                    return;
                }
                $count_entry = $counts{$contig_id};
            }
            else {
                $counts{$contig_id}{contigs_overlapping} = $overlap;
                $count_entry = $counts{$contig_id};
            }

            #check that we don't have a duplicate label
            if(exists($count_entry->{$label})) {
                $self->error_message("Duplicate data or duplicate label for $contig_id with label $label");
                return;
            }

            @{$count_entry->{$label}}{@bam_specific_fields} = @fields[2..$#fields]; #store the info
        }
    }

    #now we're all done, lets spit this stuff out. 

    #spit out a header, cause that's a good idea

    print join("\t", @contig_specific_fields); 
    foreach my $label (@orig_labels) {
        my @labeled_fields =  map { "${label}_$_" } @bam_specific_fields;
        print "\t", join("\t", @labeled_fields);
    }
    print "\n";

    #now print the data
    foreach my $contig_id (sort keys %counts) {
        print join("\t",$contig_id, $counts{$contig_id}{contigs_overlapping});
        foreach my $label (@orig_labels) {
            print "\t",join("\t",@{$counts{$contig_id}{$label}}{@bam_specific_fields})
        }
        print "\n";
    }
    return 1;
}


1;

sub help_brief {
    "Scans a file of contigs, parses information about where they need to be counted and then spits out info."
}

sub help_detail {
    <<'HELP';
HELP
}
