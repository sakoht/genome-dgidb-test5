#!/usr/bin/env perl

use strict;
use warnings;

BEGIN {
    $ENV{UR_DBI_NO_COMMIT} = 1;
    $ENV{UR_USE_DUMMY_AUTOGENERATED_IDS} = 1;
}
use above "Genome";
use Test::More tests => 16;

my $m = Genome::Model->get(2771359026); 
ok($m, "got a model"); 

# we may build and build again, but just test this build...
# TODO: mock
#my $build_id = 96402993; This build does not exist anymore. 
my $build_id = 97848505;
my @completed = $m->completed_builds;
for my $b (@completed) {
    next if $b->id == $build_id;
    my $e = $b->build_event;
    $e->event_status('Running');    
    $e->date_completed(undef);
}

my $last_complete_build = $m->last_complete_build;
unless ($last_complete_build->id == $build_id) {
    die "Failed to force model " . $m->id . " to use build " . $build_id . " as its last complete build.  Got " . $last_complete_build->id;
}

my $refseq = 'all_sequences';

my @var = $m->_variant_list_files();
ok(scalar @var, "identified " . scalar @var . " snp files of $refseq");
ok(all_exist(@var),"the snp files exist") or diag('example path: ' .$var[0]);

@var = $m->_variant_detail_files();
ok(scalar @var, "identified " . scalar @var . " pileup files of $refseq");
ok(all_exist(@var),"the pileup files exist") or diag('example path: ' . $var[0]);

@var = $m->_variation_metrics_files();
ok(scalar @var, "identified " . scalar @var . " variation metrics files of $refseq");

SKIP: {
    skip 'We do not generate other_snp_related_metrics subdir right now', 1;
    ok(all_exist(@var),"the variation files exist");
}

$DB::single=1;
my $v = $m->variant_count();
is($v, 6631155, 'Got expected variant count');

my $f;

my $data_directory = $m->complete_build_directory;
#my $expected = '/gscmnt/sata821/info/model_data/2771359026/build96402993';
my $expected ='/gscmnt/sata905/info/model_data/2771359026/build97848505';
is($data_directory, $expected, "resolved data directory");  # FIX WHEN WE SWITCH MODELS

#$f = $m->resolve_accumulated_alignments_filename();
#is($f, 'FIXME', "found accumulated alignments file name"); #FIXME WHEN WE SWITCH MODELS

$f = $m->accumulated_alignments_directory();
is($f, "$data_directory/alignments", "found alignments directory");

#@f = $m->maplist_file_paths();
#is(scalar(@f), 'FIXME', "found maplist file paths"); #FIXME WHEN WE SWITCH MODELS

my $human_ref_seq_build = Genome::Model::Build::ImportedReferenceSequence->get_by_name('NCBI-human-build36');
ok($human_ref_seq_build, 'Got ImportedReferenceSequence build for "NCBI-human-build36"');
my $mouse_ref_seq_build = Genome::Model::Build::ImportedReferenceSequence->get_by_name('NCBI-mouse-build37');
ok($mouse_ref_seq_build, 'Got ImportedReferenceSequence build for "NCBI-mouse-build37"');

my $matched_version_model = Genome::Model::ReferenceAlignment->create(reference_sequence_build => $human_ref_seq_build, subject_name => "H_HY-03023", name => "test-matched", processing_profile_id => "2514936"); #This processing profile is for build36
ok(!$matched_version_model->__errors__, "Matching reference sequences and annotation versions is ok");
my $no_annotation_model = Genome::Model::ReferenceAlignment->create(reference_sequence_build => $human_ref_seq_build, subject_name => "H_HY-03023", name => "test-no-annotation", processing_profile_id => "2342875"); #This processing profile has no annotation
ok(!$no_annotation_model->__errors__, "No annotation is ok");
my $mismatched_version_model = Genome::Model::ReferenceAlignment->create(reference_sequence_build => $human_ref_seq_build, subject_name => "H_HY-03023", name => "test-mismatched-version", processing_profile_id => "2516017"); #This processing_profile is human annotation build37
ok($mismatched_version_model->__errors__, "Can't specify a model with ref. seq. and annotation with different versions");
my $mismatched_species_model = Genome::Model::ReferenceAlignment->create(reference_sequence_build => $mouse_ref_seq_build, subject_name => "H_HY-03023", name => "test-mismatched-species", processing_profile_id => "2516017"); #This processing_profile is human annotation build37
ok($mismatched_species_model->__errors__, "Can't specify a model with ref. seq. and annotation versions of different species");

sub all_exist {
    return (!(grep{ ! -e $_ } @_) ? 1 : 0);
}

