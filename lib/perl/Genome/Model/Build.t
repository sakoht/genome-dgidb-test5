#!/usr/bin/env perl

# FIXME Tests to cover:
# Allocation - all allocation in builds are not tested
# Reports - limited report testing

use strict;
use warnings;

use above 'Genome';
use Data::Dumper 'Dumper';
use Test::More; 

$ENV{UR_DBI_NO_COMMIT} = 1;
$ENV{UR_USE_DUMMY_AUTOGENERATED_IDS} = 1;

# Create temporary test subclasses
class Genome::ProcessingProfile::Test {
    is => 'Genome::ProcessingProfile',
};
sub Genome::ProcessingProfile::Test::_execute_build { return 1 };

class Genome::InstrumentData::Test {
    is => 'Genome::InstrumentData',
};

class Genome::Model::Test {
    is => 'Genome::Model',
};

class Genome::Model::Build::Test {
    is => 'Genome::Model::Build',
};

# Create sample, library, instrument data, processing profile
my $sample = Genome::Sample->create(
    name => 'test sample'
);

my $library = Genome::Library->create(
    sample_id => $sample->id,
    name => 'test library',
);

my $inst_data = Genome::InstrumentData::Test->create(
    sequencing_platform => 'test',
    library_id => $library->id,
);

my $pp = Genome::ProcessingProfile::Test->create(
    name => 'test pp',
);

# Create test model and make sure inputs and such are correct
my $model = Genome::Model::Test->create(
    subject_id => $sample->id,
    subject_class_name => $sample->class,
    processing_profile_id => $pp->id,
    name => 'test model',
);
ok($model, 'created test model') or die;
isa_ok($model, 'Genome::Model::Test', 'model subclass automagically generated');
$model->add_instrument_data(value => $inst_data);
my @model_inst_data = $model->instrument_data;
ok(@model_inst_data, 'Added instrument data to model');
my @model_inputs = $model->inputs;
is(scalar(@model_inputs), 1, 'Correct number of model inputs');

# Create test build
my $build = Genome::Model::Build::Test->create(
    model_id => $model->id,
);
ok($build, 'Created build') or die;
isa_ok($build, 'Genome::Model::Build::Test', 'build subclass automagically generated');
ok($build->the_master_event, 'master event created');
is($build->model->id, $model->id, 'indirect model accessor');
is($build->status, 'New', 'status set to New');

# Make sure inputs were copied to build
my @build_inputs = $build->inputs;
is(scalar(@build_inputs), 1, 'Correct number of build inputs');
my @build_inst_data = $build->instrument_data;
is($build->instrument_data_count, 1, 'Instrument data count');
is_deeply(\@build_inst_data, \@model_inst_data, 'Build instrument data matches model instrument data');

# TODO Check that model is updated via check_for_updates and that _initialize_build is called on pp

# Make sure build start fails when validate_for_start returns false
no warnings 'redefine';
my $tag = UR::Object::Tag->create(properties => ['foo'], desc => 'test tag');
*Genome::Model::Build::Test::validate_for_start = sub { return $tag };
use warnings;

ok(!$build->start, 'build failed to start, as expected');
my @notes = Genome::MiscNote->get(
    subject => $build,
    header_text => 'Unstartable',
);
ok(@notes, 'got unstartable notes from build');
ok(scalar(@notes) == 1, 'got exactly one unstartable note back');
ok($notes[-1]->body_text =~ /could not be validated for start/, 'error message matches expected');
is($build->status, 'Unstartable', 'build status set to unstartable');

# Now set validate_for_start to return true
no warnings 'redefine';
*Genome::Model::Build::Test::validate_for_start = sub { return };
use warnings;

$model->build_requested(1);
ok($build->start(job_dispatch => 'inline', server_dispatch => 'inline'), 'build started!');
is($build->status, 'Succeeded', 'build completed successfully');
ok($build->data_directory, 'data directory resolved');
ok($build->software_revision, 'software revision set on build');
is($model->build_requested, 0, 'build requested unset on model');

# Check to addressees for reports
my $build_event = $build->the_master_event;
my $user = $build_event->user_name;
my $to = $build->_get_to_addressees_for_report_generator_class('Genome::Model::Report::BuildInitialized');
is($to, $user.'@genome.wustl.edu', 'initialized report goes to user');
$to = $build->_get_to_addressees_for_report_generator_class('Genome::Model::Report::BuildSucceeded');
is($to, $user.'@genome.wustl.edu', 'succeeded report goes to user');
$to = $build->_get_to_addressees_for_report_generator_class('Genome::Model::Report::BuildFailed');
is($to, $user.'@genome.wustl.edu', 'failed report goes to user');

$build_event->user_name('apipe-builder'); # changing to apipe-builder
$to = $build->_get_to_addressees_for_report_generator_class('Genome::Model::Report::BuildInitialized');
ok(!$to, 'initialized report for apipe-builder does not get sent');
$to = $build->_get_to_addressees_for_report_generator_class('Genome::Model::Report::BuildSucceeded');
ok(!$to, 'succeeded report for apipe-builder does not get sent');
$to = $build->_get_to_addressees_for_report_generator_class('Genome::Model::Report::BuildFailed');
is($to, 'apipe-builder@genome.wustl.edu', 'failed report for apipe-builder gets sent');

# do not send the report
my $gss_report = *Genome::Model::Build::generate_send_and_save_report;
no warnings 'redefine';
*Genome::Model::Build::generate_send_and_save_report = sub{ return 1; };
use warnings;

# FAIL
ok($build->fail(), 'Fail');
is($build->status, 'Failed', 'Status is Failed');
ok($model->build_needed, 'This failed build does not satisfy the model');

# SUCCESS
ok($build->success, 'Success');
is($build->status, 'Succeeded', 'Status is Succeeded');
ok(!$model->current_running_build_id, 'Current running build id set to undef in success');
is($model->_last_complete_build_id, $build->id, 'Model last complete build is set to this build\'s id in success');
ok(!$model->build_needed, 'This succeeded build satisfies the model');

# ABANDON
ok($build->abandon, 'Abandon');
is($build->status, 'Abandoned', 'Status is Abandoned');
isnt($model->last_complete_build_id, $build->id, 'Model last complete build is not this build\'s id in abandon');
# try to init, fail and succeed a abandoned build
ok(!$build->initialize, 'Failed to initialize an abandoned build');
ok(!$build->fail, 'Failed to fail an abandoned build');
ok(!$build->success, 'Failed to success an abandoned build');

no warnings 'redefine';
*Genome::Model::Build::generate_send_and_save_report = $gss_report;
use warnings;

# Delete build
ok($build->delete, 'Deleted build');

test_failure_notes();

done_testing();
exit;

sub test_failure_notes {
    #Ensure that when builds fail, they add notes, equivlent to the failure email's stage, step, and error

    my $transaction = UR::Context::Transaction->begin;

    my $sample = Genome::Sample->create(name => 'TEST');
    isa_ok($sample, 'Genome::Sample', 'sample');
    class Genome::ProcessingProfile::Tester {
        is => 'Genome::ProcessingProfile'
    };
    sub Genome::ProcessingProfile::Tester::sequencing_platform { return 'solexa' };
    my $pp = Genome::ProcessingProfile->create(
        name => 'Tester PP',
        type_name => 'tester',
    );
    isa_ok($pp, 'Genome::ProcessingProfile', 'pp');

    my $model = Genome::Model->create(
        name => 'Test Model',
        processing_profile => $pp,
        subject_id => $sample->id,
        subject_class_name => $sample->class,
    );
    isa_ok($model, 'Genome::Model', 'model');

    class Genome::Model::Build::Tester {
        is => 'Genome::Model::Build'
    };
    sub Genome::Model::Build::Tester::generate_send_and_save_report { return 1 };

    my $build = Genome::Model::Build->create(
        model => $model
    );
    isa_ok($build, 'Genome::Model::Build', 'build');

    my $error = Genome::Model::Build::Error->create(
        build_event_id => $build->build_event->id,
        stage_event_id => $build->build_event->id,
        stage => 'all stages',
        step_event_id => $build->build_event->id,
        step => 'main',
        error => 'Testing error',
    );
    isa_ok($error, 'Genome::Model::Build::Error', 'error');

    $build->fail($error);

    my $failed_step_note = $build->notes(header_text => 'Failed Step');
    isa_ok($failed_step_note, 'Genome::MiscNote', 'failed_step_note');
    is($failed_step_note->body_text, $error->step, 'failed step matches error step');

    my $failed_stage_note = $build->notes(header_text => 'Failed Stage');
    isa_ok($failed_stage_note, 'Genome::MiscNote', 'failed_stage_note');
    is($failed_stage_note->body_text, $error->stage, 'failed stage matches error stage');

    my $failed_error_note = $build->notes(header_text => 'Failed Error');
    isa_ok($failed_error_note, 'Genome::MiscNote', 'failed_error_note');
    is($failed_error_note->body_text, $error->error, 'failed error matches error error');

    $transaction->rollback;
}
