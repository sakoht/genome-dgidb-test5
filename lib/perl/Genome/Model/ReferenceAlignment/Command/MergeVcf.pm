package Genome::Model::ReferenceAlignment::Command::MergeVcf;

class Genome::Model::ReferenceAlignment::Command::MergeVcf {
    is => 'Command::V2',
    doc => 'Merge merged.vcf outputs from many samples into one vcf',
    has => [
        model_group => {
            is => 'Genome::ModelGroup',
            is_many => 1,
            shell_args_position => 1,
            doc => 'build to prepare',
        },
        output_file => {
            is => 'Text',
            doc => 'Path to the multi-sample merged vcf to output',
        },
        output_list_file => {
            is => 'Text',
            doc => "This is the list of input vcf's and their corresponding sample names, generated by the tool.",
            is_optional => 1,
        },
        use_gzipped_vcfs => {
            is => 'Boolean',
            doc => "Set this to operate on gzipped vcfs (and make them if they aren't there) and to output gzipped result",
            default => 0,
        },
    ],
};

sub help_detail {
    return <<EOS 
    Use this to merge VCF's from multiple reference-alignments into one 
EOS
}

sub execute {
    my $self = shift;

    my $output_file = $self->output_file;
    my $output_list = $self->output_list_file || $self->output_file.".list";
    if(-e $output_file){
        die $self->error_message("Output file already exists at: ".$output_file);
    }
    if(-e $output_list){
        die $self->error_message("Output list file already exists at: ".$output_list);
    }

    my @mg = $self->model_group;
    my @input_vcfs; 

    my %inputs;

    my $list_fh = Genome::Sys->open_file_for_writing($output_list);

  
    #go through each model group and each model, pulling latest builds, checking for vcfs, and aggregating paths to them
    for my $mg (@mg) {
        for my $model ($mg->models){
            my $build = $model->last_succeeded_build;
            unless($build){
                $self->status_message("Skipping model: ".$model->id.". It no succeeded builds.");
                next;
            }
            my $sample = $model->subject->name;
            unless($sample){
                die $self->error_message("Could not find a sample name for model: ".$model->id);
            }
            if(exists($inputs{$sample})){
                die $self->error_message("Encountered multiple builds for one sample: ".$sample);
            }
            if ($self->use_gzipped_vcfs) {
                unless($self->check_for_and_create_gz($build)){
                    $self->status_message("Not including model: ".$model->id." as it had no merged vcf.");
                    next;
                }
                $inputs{$sample} = $build->get_merged_vcf.".gz";
            } else {
                $inputs{$sample} = $build->get_merged_vcf;
            }

            print $list_fh $inputs{$sample}."\t".$sample."\t".$build->id."\n";
        }
    }

    $list_fh->close;

    my $gzip = $self->use_gzipped_vcfs || 0;

    my $join_cmd = Genome::Model::Tools::Vcf::MultiSampleJoinVcf->create(
        output_file => $output_file,
        vcf_list => $output_list,
        intersection => 0,
        use_gzip_files => $gzip,
    );
    unless($join_cmd->execute){
        die $self->error_message("Could not execute MultiSampleJoinVcf command!");
    }

    unless(-s $output_file){
        die $self->error_message("Could not find output file!");
    } 
    return 1;
}

#if the vcf is not gzipped and indexed for tabix, do so and reallocate the host build
sub check_for_and_create_gz {
    my $self = shift;
    my $build = shift;
    my $merged_vcf = $build->get_merged_vcf;
    my $merged_vcf_gz = $merged_vcf.".gz";
    my $merged_vcf_gz_tbi = $merged_vcf_gz.".tbi";
    unless(-e $merged_vcf_gz){
        unless(-e $merged_vcf){
            die $self->error_message("Could not locate merged VCF at: ".$merged_vcf);
        }
        my $cmd = "bgzip -c ".$merged_vcf." > ".$merged_vcf_gz;
        Genome::Sys->shellcmd( cmd => $cmd);
        unless(-e $merged_vcf_gz){
            die $self->error_message("Tried to create gzipped merged vcf, but failed.");
        }
    }
    unless(-e $merged_vcf_gz_tbi){
        my $tbi_cmd = "tabix -p vcf ".$merged_vcf_gz;
        unless(Genome::Sys->shellcmd( cmd => $tbi_cmd)){
            die $self->error_message("Could not create tabix index file for: ".$merged_vcf_gz);
        }
        unless(-e $merged_vcf_gz_tbi ){
            die $self->error_message("Could not create tabix index file for: ".$merged_vcf_gz);
        }
    }
    if($changes){
        $self->_needs_commit(1);
        my $build_allocation = $build->disk_allocation;
        $build_allocation->reallocate;
        UR::Context->commit;
    }
    return 1;
}

1;
