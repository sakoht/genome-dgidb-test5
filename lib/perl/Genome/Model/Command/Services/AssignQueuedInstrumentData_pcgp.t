#!/usr/bin/env perl

use strict;
use warnings;

BEGIN {
    $ENV{UR_DBI_NO_COMMIT} = 1;
    $ENV{UR_USE_DUMMY_AUTOGENERATED_IDS} = 1;
    $ENV{UR_COMMAND_DUMP_STATUS_MESSAGES} = 1;
}

use above 'Genome';

use Data::Dumper;
use Test::MockObject;
use Test::More;

use_ok('Genome::Model::Command::Services::AssignQueuedInstrumentData') or die;

my $qidfgm_cnt = 0;
my $sample_cnt = 0;
my (@samples, @instrument_data, @index_illumina, @pses, @pse_params);
no warnings;
my $instrument_data_get = Genome::InstrumentData->can('get');
*Genome::InstrumentData::get = sub {
    my ($class, %params) = @_;
    if ( $params{'attributes.attribute_label'} ) { # getting new inst data, only return what we just created
        return grep { $_->attributes(attribute_label => 'tgi_lims_status')->attribute_value eq 'new' } @instrument_data;
    } 
    else {
        return $instrument_data_get->(@_);
    } 
};
sub GSC::PSE::get { return grep { $_->pse_status eq 'inprogress' } @pses; }
sub GSC::IndexIllumina::get { my ($class, $id) = @_; for my $index_illumina ( @index_illumina ) { return $index_illumina if $index_illumina->id == $id; } }
use warnings;

my $gsc_project = Test::MockObject->new();
$gsc_project->set_isa('Genome::Site::TGI::SetupProjectResearch');
$gsc_project->set_always(id => -444);
$gsc_project->set_always(setup_id => -444);
$gsc_project->set_always(name => 'PCGP__TEST_PROJECT__');
$gsc_project->set_always(setup_name => 'PCGP__TEST_PROJECT__');
my $gsc_workorder = Test::MockObject->new();
$gsc_workorder->set_isa('Genome::Site::TGI::SetupWorkOrder');
$gsc_workorder->set_always(id => -222);
$gsc_workorder->set_always(name => '__TEST_WORKORDER__');
$gsc_workorder->set_always(setup_name => '__TEST_WORKORDER__');
$gsc_workorder->set_always(get_project => $gsc_project);
$gsc_workorder->set_always(project_id => -12345);
$gsc_workorder->set_always(research_project_name => "PCGP TEST"); #this is what determines the pp

my $genome_project = Genome::Project->create( id => $gsc_project->setup_id, name => $gsc_project->setup_name );
ok( $genome_project, 'Define genome project' );
my $pp_id = 2644306;

my $bac_source = Genome::Individual->__define__(
    name => '__TEST_SOURCE__', 
    taxon => Genome::Taxon->__define__(name => 'human', domain => 'Human', species_latin_name => 'Homo sapiens'),
);
ok($bac_source, 'define pcgp source');
ok($bac_source->taxon, 'define pcgp taxon');
my $pp = Genome::ProcessingProfile->get($pp_id);
ok($pp, 'got pcgp pp');
ok(_qidfgm($bac_source), 'create qidfgm for pcgp taxon');
is(@instrument_data, $qidfgm_cnt, "create $qidfgm_cnt inst data");
is(@pses, $qidfgm_cnt, "create $qidfgm_cnt pses");

my $cmd = Genome::Model::Command::Services::AssignQueuedInstrumentData->create(test => 1);
ok($cmd, 'create aqid');
$cmd->dump_status_messages(1);
ok($cmd->execute, 'execute');
my @new_models = values %{$cmd->_newly_created_models};
my %new_models = _model_hash(@new_models);
my @existing_models = values %{$cmd->_existing_models_assigned_to};
my %existing_models = _model_hash(@existing_models);
#print Dumper(\%new_models,\%existing_models);
is_deeply(
    \%new_models,
    {
        "AQID-testsample1.human.prod-refalign" => {
            subject => $samples[0]->name,
            processing_profile_id => $pp_id,
            inst => [ $instrument_data[0]->id ],
            auto_assign_inst_data => 1,
        },
    },
    'new models',
);
is_deeply(
    [ map { $_->attribute_value } map { $_->attributes(attribute_label => 'tgi_lims_status') } @instrument_data ],
    [ map { 'processed' } @instrument_data ],
    'set tgi lims status to processed for all instrument data',
);
my @projects = Genome::Project->get('name in' => [ map { $_->setup_name } $gsc_project, $gsc_workorder ]);
is(@projects, 2, 'created projects');
is_deeply(
    [ sort { $a <=> $b } map { $_->id } @projects ],
    [ sort { $a <=> $b } map { $_->id } ($gsc_project, $gsc_workorder) ],
    'project ids match gsc entity ids',
);
my @model_groups = Genome::ModelGroup->get(uuid => [ map { $_->id } @projects ]);
is(@model_groups, 2, 'created model groups');

done_testing();
exit;

sub _qidfgm {
    my $source = shift;
    $qidfgm_cnt++;
    $sample_cnt++;
    my $sample = Genome::Sample->__define__(
        name => 'AQID-testsample'.$sample_cnt.'.'.lc($source->taxon->name),
        source => $source,
        extraction_type => 'genomic',
    );
    ok($sample, 'sample '.$sample_cnt);
    push @samples, $sample;
    my $library = Genome::Library->__define__(
        name => $sample->name.'-testlib',
        sample_id => $sample->id,
    );
    ok($library, 'create library '.$qidfgm_cnt);

    my $instrument_data = Genome::InstrumentData::Solexa->__define__(
        library_id => $library->id,
    );
    ok($instrument_data, 'created instrument data '.$qidfgm_cnt);
    push @instrument_data, $instrument_data;
    $instrument_data->add_attribute(
        attribute_label => 'tgi_lims_status',
        attribute_value => 'new',
    );

    my $index_illumina = Test::MockObject->new();
    push @index_illumina, $index_illumina;
    $index_illumina->set_always(id => $instrument_data->id);
    $index_illumina->set_always(copy_sequence_files_confirmed_successfully => 1);
    $index_illumina->set_always(get_research_projects => $gsc_project);
    $index_illumina->set_always(get_work_orders => $gsc_workorder);
    ok($index_illumina, 'created index illumina '.$qidfgm_cnt);

    my $ref_seq_build = Genome::Model::Build::ImportedReferenceSequence->get(name => 'NCBI-human-build36');
    my $pse = Test::MockObject->new();
    $pse->set_always(pse_status => 'inprogress');
    $pse->set_always(id => $qidfgm_cnt - 10000);
    $pse->set_always(pse_id => $qidfgm_cnt - 10000);
    $pse->set_always(ps_id => 3733);
    $pse->set_always(ei_id => '464681');
    ok($pse, 'create pse '.$qidfgm_cnt);
    $pse->mock(
        add_param => sub{
            my ($pse, $key, $value) = @_;
            my $param = Test::MockObject->new();
            push @pse_params, $param;
            $param->set_always(pse_id => $pse->id);
            $param->set_always(param_name => $key);
            $param->set_always(param_value => $value);
            return $param;
        }
    );
    $pse->mock(
        added_param => sub{
            my ($pse, $key) = @_;
            for my $param ( @pse_params ) {
                return $param->param_value if $param->pse_id == $pse->id and $param->param_name eq $key;
            }
            return;
        }
    );
    $pse->mock(
        get_inherited_assigned_directed_setups_filter_on => sub{
            my $self = shift;
            my $filter = shift;
            my @a;
            push @a, $gsc_workorder if $filter eq 'setup work order';
            push @a, $gsc_project if $filter eq 'setup project';
            return @a;
        },
    );
    $pse->mock(
        add_reference_sequence_build_param_for_processing_profile => sub {
            return 1;
        },
    );
    $pse->mock(
       reference_sequence_build_param_for_processing_profile => sub {
            return $ref_seq_build->id;
       },
    );
    my %params = (
        instrument_data_type => 'solexa',
        instrument_data_id => $instrument_data->id,
        subject_class_name => 'Genome::Sample',
        subject_id => $sample->id,
    );
    for my $key ( keys %params ) {
        $pse->add_param($key, $params{$key});
    }
    push @pses, $pse;
    return 1;
}

sub _model_hash {
    return map { 
        $_->name => { 
            subject => $_->subject_name, 
            processing_profile_id => $_->processing_profile_id,
            inst => [ map { $_->id } $_->instrument_data ],
            auto_assign_inst_data => $_->auto_assign_inst_data,
        }
    } @_;
}

