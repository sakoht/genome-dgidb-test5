package Genome::Model::Command::Define;

use strict;
use warnings;

use Genome;
use Genome::Model::Command::Define::Helper;

class Genome::Model::Command::Define {
    is => 'Command::SubCommandFactory', 
    is_abstract => 1,
};

# Compiling this class autogenerates one sub-command per model type.
# These are the commands which actually execute, and either inherit from this
# class or from those returned by _sub_commands_inherit_from.
sub _sub_commands_from { 'Genome::Model' }

# Sub commands generated by this class will inherit from the class(es) specified here.
sub _sub_commands_inherit_from {'Genome::Model::Command::Define::Helper'}
 
sub _build_sub_command {
    my ($self, $class_name, @inheritance) = @_;

    my $model_subclass_name = $class_name;
    $model_subclass_name =~ s/::Command::Define::/::/;
    my $model_subclass_meta = UR::Object::Type->get($model_subclass_name);
    if ($model_subclass_meta and $model_subclass_name->isa('Genome::Model')) {
        my @p = $model_subclass_meta->properties();
        my @has;
        for my $p (@p) {
            if ($p->can("is_input") and $p->is_input) {
                my %data = %{ UR::Util::deep_copy($p) };
                for my $key (keys %data) {
                    delete $data{$key} if $key =~ /^_/;
                }                
                delete $data{id};
                delete $data{db_committed};
                delete $data{via};
                delete $data{to};
                my $name = $p->property_name;
                push @has, $name, \%data;
            }
        }
        my $build_subclass_meta = UR::Object::Type->define(
            class_name => $class_name,
            is => \@inheritance,
            has_input => \@has,
        );
        return $class_name;
    }

    return;
}

1;

